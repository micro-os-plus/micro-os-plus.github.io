<!doctype html>

<html lang="en">


<head>

  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Event flags</title>
  <meta name="description" content="A POSIX inspired open source framework, written in C++.">

  <meta property="og:title" content="Event flags" />
  <meta property="og:site_name" content="µOS++" />

  <link rel="alternate" type="application/rss+xml" title="µOS++" href="/feed.xml" />


  <meta property="article:published_time" content="2016-07-15">





  <meta name="google-site-verification" content="NT_y3tqI_8mrd8gYA_FDWHT2-tkJExOC6KBkSnyZx6c" />

  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" type="text/css" href="/stylesheets/screen.css?202305210532" media="screen">
  <link rel="stylesheet" type="text/css" href="/stylesheets/font-awesome.css?202305210532" media="screen">
  <link rel="stylesheet" type="text/css" href="/stylesheets/print.css?202305210532" media="print">

  <link rel="canonical" href="/user-manual/event-flags/">



  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9T84WD3CK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E9T84WD3CK');
</script>



</head>


<body>

<div class="container">

  <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

  <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

  <div class="site-header">
  <table style="width:100%">
    <tr>
      <td>
        <a href="/">
          <img alt="Icon" class="site-icon" src="/assets/icons/wall-e-icon.png" height="100" width="100">
      </a>
      </td>
      <td>
        <table class="site-title" style="width:100%">
          <tr>
            <td class="site-title">
              <a href="/">µOS++</a>
            </td>
            <td class="site-motto" align="right">
              “Perfekt ist nicht gut genug”
            </td>
          </tr>
          <tr>
            <td class="site-description" colspan="2">
              A POSIX inspired open source framework, written in C++.
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</div>


</div>

<div class="container">

  <div class="wrapper">
    <div class="site-body">

      <div class="site-sidebar">


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      <h4 id="news"><a href="/blog/">News</a></h4>

<ul>
  <li><a href="/blog/2023/07/19/micro-os-plus-v7-0-0-released/">µOS++ v7.0.0 released</a></li>
  <li><a href="/blog/2021/05/21/micro-os-plus-v6-3-17-released/">µOS++ v6.3.17 released</a></li>
  <li><a href="/blog/2021/05/03/micro-os-plus-v6-3-16-released/">µOS++ v6.3.16 released</a></li>
  <li><a href="/blog/2021/01/22/micro-os-plus-first-scriptable-build/">First µOS++ scriptable build</a></li>
</ul>


    </div>
  </div>


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      
      <h4 id="home"><a href="/">Home</a></h4>

<h4 id="µos">µOS++</h4>

<ul>
  <li><a href="/micro-os-plus/">Overview</a></li>
  <li><a href="/micro-os-plus/iii/releases/">Releases</a></li>
</ul>

<h4 id="apis">APIs</h4>

<ul>
  <li><a href="/cmsis-plus/">Overview</a></li>
  <li><a href="/cmsis-plus/rtos/">RTOS API</a></li>
</ul>

<h4 id="xpacks">xPacks</h4>

<ul>
  <li><a href="/xpacks/">Overview</a></li>
</ul>

<h4 id="documentation">Documentation</h4>

<ul>
  <li>
<a href="/user-manual/">User’s <strong>manual</strong></a>
    <ul>
      <li><a href="/user-manual/getting-started/">Getting started</a></li>
      <li><a href="/user-manual/basic-concepts/">Basic concepts</a></li>
      <li><a href="/user-manual/features/">Features</a></li>
      <li><a href="/user-manual/threads/">Threads</a></li>
      <li><a href="/user-manual/thread-event-flags/">Thread event flags</a></li>
      <li><a href="/user-manual/semaphores/">Semaphores</a></li>
      <li><a href="/user-manual/event-flags/">Event flags</a></li>
      <li>Mutexes</li>
      <li>Condition variables</li>
      <li>Message queues</li>
      <li>Memory pools</li>
      <li>Software timers</li>
      <li>Clocks</li>
    </ul>
  </li>
  <li><a href="/reference/cmsis-plus/">µOS++ <strong>reference</strong></a></li>
</ul>

<h4 id="developer">Developer</h4>

<ul>
  <li><a href="/develop/">Overview</a></li>
  <li><a href="/reference/cmsis-plus/md_doxygen_pages_change-log.html">Change log</a></li>
  <li><a href="/develop/coding-style/">C++ coding style</a></li>
  <li><a href="/develop/naming-conventions/">Naming conventions</a></li>
  <li><a href="/develop/references/">Links &amp; references</a></li>
</ul>

<h4 id="support">Support</h4>

<ul>
  <li><a href="/support/">Overview</a></li>
  <li><a href="/support/known-issues/">Known issues</a></li>
  <li><a href="/support/faq/">FAQ</a></li>
  <li><a href="/support/forum/">Forum</a></li>
  <li><a href="https://github.com/micro-os-plus/micro-os-plus-iii/issues/">Report µOS++ issues</a></li>
</ul>

<h4 id="latest-articles">Latest Articles</h4>

<ul>
  <li><a href="/articles/arm-com-2016-06-24/">CMSIS++ RTOS: fully functional reference implementation</a></li>
  <li><a href="/articles/arm-com-2016-03-11/">CMSIS++: a proposal for a future CMSIS, written in C++</a></li>
</ul>

<h4 id="project">Project</h4>

<ul>
  <li><a href="/project/about/">About</a></li>
  <li><a href="/project/history/">History</a></li>
  <li><a href="https://opensource.org/licenses/MIT">License (MIT)</a></li>
</ul>

    </div>
  </div>

  <div class="site-theme">
    This site uses the <a href="https://github.com/ilg-ul/github-jekyll-theme">GitHub Wiki-like</a> theme by <a href="https://github.com/ilg-ul">Liviu Ionescu</a>.
  </div>

</div>


      <div class="site-content">

        
<h1 class="page-title">Event flags</h1>
<table id="last-modified">
  <tr>
    <td id="last-modified">Last modified on Wed Jul 19 11:46:15 2023 UTC.</td>
    <td id="improve" align="right"><a id="improve" href="https://github.com/micro-os-plus/web-jekyll/edit/master/pages/user-manual/event-flags.md"><i class="fa fa-pencil"></i>  Improve this page</a></td>
  </tr>
</table>

<h2 id="overview">Overview</h2>

<p>Together with semaphores, event flags are the basic µOS++ synchronisation mechanisms.</p>

<p>An event flag can be considered as a simplified binary semaphore, that can be posted from a thread or an ISR.</p>

<p>The additional value of event flags consist in their number: event flags come in groups, and threads can be synchronised on any number of flags in a group (defined by a mask). A thread may expect either all flags in a set to have occurred (conjunctive synchronisation, logical AND), or any flag in a set (disjunctive synchronisation, logical OR).</p>

<div style="text-align:center">
<img alt="Event Flags" src="/assets/images/2016/event-flags.png">
<p>Event flags</p>
</div>

<p>The event flags consists of a series of bits, based on the platform word size (32-bits for Cortex-M). The initial value for the event flags is zero (none of the flags are raised).</p>

<h2 id="creating-event-flags">Creating event flags</h2>

<p>When used to synchronise threads with ISRs, the easiest way to access event flags is when they are created as global objects.</p>

<p>In C++, the global event flags are created and initialised by the global static constructors mechanism.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.cpp</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="o">::</span><span class="n">rtos</span><span class="p">;</span>

<span class="c1">// Create a global event flags object instance.</span>
<span class="n">event_flags</span> <span class="n">ev</span> <span class="p">{</span> <span class="s">"ev"</span> <span class="p">};</span>

<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="c1">// Not much to do, the event flags were created by the static</span>
  <span class="c1">// constructors, before entering main().</span>

  <span class="c1">// ...</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// All event flags are automatically destroyed if os_main() returns.</span>

</code></pre></div></div>

<p>A similar example, but written in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.c</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os-c-api.h&gt;
</span>
<span class="c1">// Global static storage for the event flags object instance.</span>
<span class="n">os_evflags_t</span> <span class="n">ev</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="c1">// Create a global event flags object instance.</span>
  <span class="n">os_evflags_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="s">"ev"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// ...</span>

  <span class="c1">// For completeness, destroy the event flags.</span>
  <span class="n">os_evflags_destruct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In C++, if it is necessary to control the moment when global objects instances are created, it is possible to separately allocate the storage as global variables, then use the placement <code class="language-plaintext highlighter-rouge">new</code> operator to initialise them.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.cpp</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="o">::</span><span class="n">rtos</span><span class="p">;</span>

<span class="c1">// Global static storage for the event flags object instance.</span>
<span class="c1">// This storage is set to 0 as any uninitialised variable.</span>
<span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">event_flags</span><span class="p">),</span> <span class="k">alignof</span><span class="p">(</span><span class="n">event_flags</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">ev1</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="c1">// Use placement new, to explicitly call the constructor</span>
  <span class="c1">// and initialise the event flags.</span>
  <span class="c1">// Create a global event flags object instance.</span>
  <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ev1</span><span class="p">)</span> <span class="n">event_flags</span> <span class="p">{</span> <span class="s">"ev1"</span> <span class="p">};</span>

  <span class="c1">// Local static storage for the event flags object instance.</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">event_flags</span><span class="p">),</span> <span class="k">alignof</span><span class="p">(</span><span class="n">event_flags</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">ev2</span><span class="p">;</span>

  <span class="c1">// Use placement new, to explicitly call the constructor</span>
  <span class="c1">// and initialise the event flags.</span>
  <span class="c1">// Create a static event flags object instance.</span>
  <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ev2</span><span class="p">)</span> <span class="n">event_flags</span> <span class="p">{</span> <span class="s">"ev2"</span> <span class="p">};</span>

  <span class="c1">// ...</span>

  <span class="c1">// For completeness, call the event flags destructors, which for placement new</span>
  <span class="c1">// is no longer called automatically.</span>
  <span class="n">ev1</span><span class="p">.</span><span class="o">~</span><span class="n">event_flags</span><span class="p">();</span>
  <span class="n">ev2</span><span class="p">.</span><span class="o">~</span><span class="n">event_flags</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Event flags objects instances can also be created on the local stack, for example on the main thread stack. Just be sure the stack is large enough to store all defined local objects.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.cpp</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="o">::</span><span class="n">rtos</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="c1">// Create a local event flags object instance.</span>
  <span class="n">event_flags</span> <span class="n">ev1</span> <span class="p">{</span> <span class="s">"ev1"</span> <span class="p">};</span>

  <span class="c1">// Beware of local static instances, since they'll use atexit()</span>
  <span class="c1">// to register the destructor; avoid and prefer placement new, as before.</span>
  <span class="c1">// static event_flags ev2 { "ev2" };</span>

  <span class="c1">// ...</span>

  <span class="c1">// The local event flags are destroyed automatically before exiting this block.</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A similar example, but written in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.c</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os-c-api.h&gt;
</span>
<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="c1">// Local storage for the event flags object instance.</span>
  <span class="n">os_evflags_t</span> <span class="n">ev1</span><span class="p">;</span>

  <span class="c1">// Create an event flags object instance.</span>
  <span class="n">os_evflags_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev1</span><span class="p">,</span> <span class="s">"ev1"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// ...</span>

  <span class="c1">// For completeness, destroy the event flags.</span>
  <span class="n">os_evflags_destruct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev1</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For a total control over the event flags creation (for example to set a custom clock), the event flags attribute mechanism can be used.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.cpp</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="o">::</span><span class="n">rtos</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">event_flags</span><span class="o">::</span><span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
  <span class="n">attr</span><span class="p">.</span><span class="n">clock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rtclock</span><span class="p">;</span>

  <span class="c1">// Create an event flags object instance.</span>
  <span class="n">event_flags</span> <span class="n">ev</span> <span class="p">{</span> <span class="s">"ev"</span><span class="p">,</span> <span class="n">attr</span> <span class="p">};</span>

  <span class="c1">// ...</span>

  <span class="c1">// The local event flags are destroyed automatically before exiting this block.</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A similar example, but written in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.c</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os-c-api.h&gt;
</span>
<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="n">os_evflags_attr_t</span> <span class="n">attr</span><span class="p">;</span>
  <span class="n">os_evflags_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

  <span class="n">attr</span><span class="p">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">os_clock_get_rtclock</span><span class="p">();</span>

  <span class="c1">// Local storage for the event flags object instance.</span>
  <span class="n">os_evflags_t</span> <span class="n">ev</span><span class="p">;</span>

  <span class="c1">// Create an event flags object instance.</span>
  <span class="n">os_evflags_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="s">"ev"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

  <span class="c1">// ...</span>

  <span class="c1">// For completeness, destroy the event flags.</span>
  <span class="n">os_evflags_destruct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The application programmer can create an unlimited number of event flag groups (limited only by the available RAM).</p>

<h2 id="raising-event-flags">Raising event flags</h2>

<p>In programming language terms, raising flags is equivalent to OR-ing the corresponding bits in the event flags mask. Once raised, the flags remain raised until they are checked, or explicitly cleared. Raising an already raised flag is a no-op.</p>

<p>When a thread or an ISR raises a flag, all threads that have their wait conditions satisfied will be resumed.</p>

<h3 id="raising-event-flags-from-isrs">Raising event flags from ISRs</h3>

<p>It is perfectly possible to raise event flags from ISRs, generally to synchronise waiting threads with events occurring on interrupts.</p>

<h2 id="waiting-for-event-flags">Waiting for event flags</h2>

<p>A thread can check at any time if an expected set of flags are raised; it is possible to check if <strong>all</strong> flags in a set are raised, or if <strong>any</strong> flag in a set is raised.</p>

<p>It’s up to the application to determine what each bit in the event flags mask  means and it is possible to use as many event flags as needed.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.cpp</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">os</span><span class="o">::</span><span class="n">rtos</span><span class="p">;</span>

<span class="n">event_flags</span> <span class="n">ev</span> <span class="p">{</span> <span class="s">"ev"</span> <span class="p">};</span>

<span class="c1">// Thread function.</span>
<span class="kt">void</span><span class="o">*</span>
<span class="nf">th_func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Wait for two event flags.</span>
  <span class="n">result_t</span> <span class="n">res</span><span class="p">;</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">ev</span><span class="p">.</span><span class="n">timed_wait</span><span class="p">(</span><span class="mh">0x3</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">os_ok</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">trace</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"Both flags raised</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">ETIMEDOUT</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">trace</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"Timeout</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="c1">// Create the thread. Stack is dynamically allocated.</span>
  <span class="kr">thread</span> <span class="n">th</span> <span class="p">{</span> <span class="s">"th"</span><span class="p">,</span> <span class="n">th_func</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>

  <span class="c1">// Raise one flag. The condition is not enough to resume the thread.</span>
  <span class="n">ev</span><span class="p">.</span><span class="n">raise</span><span class="p">(</span><span class="mh">0x1</span><span class="p">);</span>

  <span class="c1">// Pretend the thread has something important to do.</span>
  <span class="n">sysclock</span><span class="p">.</span><span class="n">sleep_for</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

  <span class="c1">// Raise second flag. The thread will be resumed.</span>
  <span class="n">ev</span><span class="p">.</span><span class="n">raise</span><span class="p">(</span><span class="mh">0x2</span><span class="p">);</span>

  <span class="c1">// Wait for the thread to terminate.</span>
  <span class="n">th</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A similar example, but written in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @file app-main.c</span>
<span class="cp">#include &lt;cmsis-plus/rtos/os-c-api.h&gt;
</span>
<span class="c1">// Global static storage for the event flags object instance.</span>
<span class="n">os_evflags_t</span> <span class="n">ev</span><span class="p">;</span>

<span class="c1">// Thread function.</span>
<span class="kt">void</span><span class="o">*</span>
<span class="nf">th_func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Wait for two event flags.</span>
  <span class="c1">// In C there are no defaults, all parameters must be specified.</span>
  <span class="n">os_result_t</span> <span class="n">res</span><span class="p">;</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">os_evflags_timed_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">os_flags_mode_all</span> <span class="o">|</span> <span class="n">os_flags_mode_clear</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">os_ok</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">trace_printf</span><span class="p">(</span><span class="s">"Both flags raised</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">ETIMEDOUT</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">trace_printf</span><span class="p">(</span><span class="s">"Timeout</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">os_main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="c1">// Create a global event flags object instance.</span>
  <span class="n">os_evflags_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="s">"ev"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Local storage for the thread object.</span>
  <span class="n">os_thread_t</span> <span class="n">th</span><span class="p">;</span>

  <span class="c1">// Initialise the thread object and allocate the thread stack.</span>
  <span class="n">os_thread_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="s">"th"</span><span class="p">,</span> <span class="n">th_func</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Raise one flag. The condition is not enough to resume the thread.</span>
  <span class="n">os_evflags_raise</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Pretend the thread has something important to do.</span>
  <span class="n">os_sysclock_sleep_for</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

  <span class="c1">// Raise second flag. The thread will be resumed.</span>
  <span class="n">os_evflags_raise</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Wait for the thread to terminate.</span>
  <span class="n">os_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// ...</span>

  <span class="c1">// For completeness, destroy the thread.</span>
  <span class="n">os_thread_destruct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">);</span>

  <span class="c1">// For completeness, destroy the event flags.</span>
  <span class="n">os_evflags_destruct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To check if any flag in the set is raised, use <code class="language-plaintext highlighter-rouge">flags::mode::any</code> (in C use <code class="language-plaintext highlighter-rouge">os_flags_mode_any</code>).</p>

<h2 id="multiple-threads-waiting-on-event-flags">Multiple threads waiting on event flags</h2>

<p>It is possible for several threads to wait on the same event flags object (regardless if the bits are the same bits or different), each thread with its own timeout.</p>

<p>When a thread or an ISR raises a flag in an event flags object, all threads that have their wait conditions satisfied will be resumed.</p>

<h2 id="other-event-flags-functions">Other event flags functions</h2>

<p>As presented in the above example, the common use case of the event flags is to automatically clear the raised flags after testing. For special cases it might be useful to individually read and clear each flag.</p>

<h3 id="getting-the-event-flags-name">Getting the event flags name</h3>

<p>The event flags name is an optional string defined during the event flags object instance creation. It is generally used to identify the event flags during debugging sessions.</p>

<p>The C++ API is:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">event_flags</span> <span class="n">ev</span> <span class="p">{</span> <span class="s">"ev"</span> <span class="p">};</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="n">ev</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
</code></pre></div></div>

<p>The C API is:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os_evflags_t</span> <span class="n">ev</span><span class="p">;</span>
<span class="n">os_evflags_construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="s">"ev"</span> <span class="err">}</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="n">os_evflags_get_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="getting-individual-flags">Getting individual flags</h3>

<p>It is possible to selectively read event flags, and possibly clear them afterwards. To prevent clearing, pass a 0 mode value.</p>

<p>Only the flags present in the mask are affected.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flags</span><span class="o">::</span><span class="n">mask_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">ev</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mh">0x2</span><span class="p">,</span> <span class="n">flags</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">clear</span><span class="p">);</span>
</code></pre></div></div>

<p>A similar example, but written in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os_flags_mask_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">os_evflags_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="n">os_flags_mode_clear</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="clearing-individual-flags">Clearing individual flags</h3>

<p>It is possible to selectively clear event flags, and possibly get the value of the flags before clearing. If the passed pointer is null, the previous values of the selected flags are lost.</p>

<p>Only the flags present in the mask are affected.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flags</span><span class="o">::</span><span class="n">mask_t</span> <span class="n">mask</span><span class="p">;</span>
<span class="n">ev</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span><span class="mh">0x2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
</code></pre></div></div>

<p>A similar example, but written in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os_flags_mask_t</span> <span class="n">mask</span><span class="p">;</span>
<span class="n">os_evflags_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="destroying-event-flags">Destroying event flags</h2>

<p>In C++, if the event flags were created using the normal way, the destructors are automatically invoked when the current block exits, or, for the global event flags instances, after the <code class="language-plaintext highlighter-rouge">main()</code> function returns. Event flags created with placement <code class="language-plaintext highlighter-rouge">new</code> need to be destructed manually.</p>

<p>In C, all event flags must be destructed by explicit calls to <code class="language-plaintext highlighter-rouge">os_evflags_destruct()</code>.</p>

<p>There should be no threads waiting on the event flags when the object is destroyed, otherwise an assert check will trigger.</p>








<ul class="share-buttons">
  <li><div class="tw-share-button"><a href="https://twitter.com/share" class="twitter-share-button" data-count="none">Tweet</a></div></li>
  <li><div class="fb-share-button" data-href="http://micro-os-plus.github.io/user-manual/event-flags/" data-layout="button"></div></li>
</ul>



      </div>

    </div>
  </div>

</div>

<div class="container">

  <div class="site-footer">
  <div class="site-footer-links left">
    <ul>
  <li>© 2023 Liviu Ionescu</li>
  <li>Hosted on GitHub</li>
  <li><a href="/feed.xml"><img src="/assets/images/feed-20.png" alt="RSS"></a></li>
  <li>
<a href="http://twitter.com/micro_os_plus" class="twitter-follow-button" data-show-count="false">Follow @micro_os_plus</a><script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</li>
</ul>


  </div>
  <a href="https://github.com/micro-os-plus/micro-os-plus-iii" aria-label="Homepage">
      <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
  </a>
  <div class="site-footer-links right">
    <ul>
  <li><a href="/">Home</a></li>
  <li><a href="/blog/">News</a></li>
  <li><a href="https://github.com/micro-os-plus/micro-os-plus-iii/releases">Releases</a></li>
  <li><a href="https://github.com/micro-os-plus/micro-os-plus-iii/issues">Support</a></li>
  <li><a href="/about/">About</a></li>
</ul>

  </div>
</div>


</div>

</body>
</html>
