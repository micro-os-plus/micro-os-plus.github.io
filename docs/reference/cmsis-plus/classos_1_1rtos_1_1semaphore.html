<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>µOS++ IIIe Reference: os::rtos::semaphore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="common-custom.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<!-- Awesome Theme Begin -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
DoxygenAwesomeInteractiveToc.init()
DoxygenAwesomeTabs.init()
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9T84WD3CK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9T84WD3CK');
</script>
<!-- Awesome Theme End -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><a href="$relpath/../../../"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign">
   <div id="projectname">µOS++ IIIe Reference<span id="projectnumber">&#160;6.3.17</span>
   </div>
   <div id="projectbrief">The third edition of µOS++, a POSIX inspired open source framework, written in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classos_1_1rtos_1_1semaphore.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classos_1_1rtos_1_1semaphore-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">os::rtos::semaphore Class Reference<div class="ingroups"><a class="el" href="group__cmsis-plus-rtos.html">µOS++ RTOS C++ API</a> &raquo; <a class="el" href="group__cmsis-plus-rtos-semaphore.html">Semaphores</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>POSIX compliant <b>semaphore</b>.  
 <a href="classos_1_1rtos_1_1semaphore.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="os_8h_source.html">cmsis-plus/rtos/os.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for os::rtos::semaphore:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classos_1_1rtos_1_1semaphore.png" usemap="#os::rtos::semaphore_map" alt=""/>
  <map id="os::rtos::semaphore_map" name="os::rtos::semaphore_map">
<area href="classos_1_1rtos_1_1internal_1_1object__named__system.html" title="Base class for named system objects." alt="os::rtos::internal::object_named_system" shape="rect" coords="119,56,348,80"/>
<area href="classos_1_1rtos_1_1internal_1_1object__named.html" title="Base class for named objects." alt="os::rtos::internal::object_named" shape="rect" coords="119,0,348,24"/>
<area href="classos_1_1rtos_1_1semaphore__binary.html" title="POSIX compliant binary semaphore." alt="os::rtos::semaphore_binary" shape="rect" coords="0,168,229,192"/>
<area href="classos_1_1rtos_1_1semaphore__counting.html" title="POSIX compliant counting semaphore." alt="os::rtos::semaphore_counting" shape="rect" coords="239,168,468,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore_1_1attributes.html">attributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphore attributes.  <a href="classos_1_1rtos_1_1semaphore_1_1attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore_1_1attributes__binary.html">attributes_binary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary semaphore attributes.  <a href="classos_1_1rtos_1_1semaphore_1_1attributes__binary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore_1_1attributes__counting.html">attributes_counting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counting semaphore attributes.  <a href="classos_1_1rtos_1_1semaphore_1_1attributes__counting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:gad6dc71df534fae5ff113a4a010511df1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#gad6dc71df534fae5ff113a4a010511df1">count_t</a> = int16_t</td></tr>
<tr class="memdesc:gad6dc71df534fae5ff113a4a010511df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of semaphore counter storage.  <br /></td></tr>
<tr class="separator:gad6dc71df534fae5ff113a4a010511df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructor</div></td></tr>
<tr class="memitem:a722459e3f83bb595777960716a15d83f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a722459e3f83bb595777960716a15d83f">semaphore</a> (const <a class="el" href="classos_1_1rtos_1_1semaphore_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="group__cmsis-plus-rtos-semaphore.html#ga6a97b5ca045e295b4928b4741f0d949e">initializer_binary</a>)</td></tr>
<tr class="memdesc:a722459e3f83bb595777960716a15d83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a semaphore object instance.  <br /></td></tr>
<tr class="separator:a722459e3f83bb595777960716a15d83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2716be8bd141fb73bfb338c31459d50a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a2716be8bd141fb73bfb338c31459d50a">semaphore</a> (const char *<a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a>, const <a class="el" href="classos_1_1rtos_1_1semaphore_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="group__cmsis-plus-rtos-semaphore.html#ga6a97b5ca045e295b4928b4741f0d949e">initializer_binary</a>)</td></tr>
<tr class="memdesc:a2716be8bd141fb73bfb338c31459d50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a named semaphore object instance.  <br /></td></tr>
<tr class="separator:a2716be8bd141fb73bfb338c31459d50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dacfa0176b4286c2784352637396b8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a4dacfa0176b4286c2784352637396b8d">~semaphore</a> ()</td></tr>
<tr class="memdesc:a4dacfa0176b4286c2784352637396b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the semaphore object instance.  <br /></td></tr>
<tr class="separator:a4dacfa0176b4286c2784352637396b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:af2a81648cf800bfbf76dd31d94b80cd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#af2a81648cf800bfbf76dd31d94b80cd4">operator==</a> (const <a class="el" href="classos_1_1rtos_1_1semaphore.html">semaphore</a> &amp;rhs) const</td></tr>
<tr class="memdesc:af2a81648cf800bfbf76dd31d94b80cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare semaphores.  <br /></td></tr>
<tr class="separator:af2a81648cf800bfbf76dd31d94b80cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a466afc9e741ec96dbd1780820789758f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a466afc9e741ec96dbd1780820789758f">post</a> (void)</td></tr>
<tr class="memdesc:a466afc9e741ec96dbd1780820789758f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post (unlock) the semaphore.  <br /></td></tr>
<tr class="separator:a466afc9e741ec96dbd1780820789758f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bf8989fbd11f6b4add24837a22cd29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a25bf8989fbd11f6b4add24837a22cd29">wait</a> (void)</td></tr>
<tr class="memdesc:a25bf8989fbd11f6b4add24837a22cd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the semaphore, possibly waiting.  <br /></td></tr>
<tr class="separator:a25bf8989fbd11f6b4add24837a22cd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c32154fdf817eed5f8ad58bbeacba56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a4c32154fdf817eed5f8ad58bbeacba56">try_wait</a> (void)</td></tr>
<tr class="memdesc:a4c32154fdf817eed5f8ad58bbeacba56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the semaphore.  <br /></td></tr>
<tr class="separator:a4c32154fdf817eed5f8ad58bbeacba56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c3e1a3b941763aa51005c767a48067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a19c3e1a3b941763aa51005c767a48067">timed_wait</a> (<a class="el" href="group__cmsis-plus-rtos-clock.html#ga149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a> timeout)</td></tr>
<tr class="memdesc:a19c3e1a3b941763aa51005c767a48067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed wait to lock the semaphore.  <br /></td></tr>
<tr class="separator:a19c3e1a3b941763aa51005c767a48067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52f748c776af2a5e067e50bbae909b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#gad6dc71df534fae5ff113a4a010511df1">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#aea52f748c776af2a5e067e50bbae909b">value</a> (void) const</td></tr>
<tr class="memdesc:aea52f748c776af2a5e067e50bbae909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the semaphore count value.  <br /></td></tr>
<tr class="separator:aea52f748c776af2a5e067e50bbae909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf4a8cefda24b57821c9cd322b33b19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a3bf4a8cefda24b57821c9cd322b33b19">reset</a> (void)</td></tr>
<tr class="memdesc:a3bf4a8cefda24b57821c9cd322b33b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the semaphore.  <br /></td></tr>
<tr class="separator:a3bf4a8cefda24b57821c9cd322b33b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a0ed04d86929e8bb9e1193cbb38da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#gad6dc71df534fae5ff113a4a010511df1">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a84a0ed04d86929e8bb9e1193cbb38da3">initial_value</a> (void) const</td></tr>
<tr class="memdesc:a84a0ed04d86929e8bb9e1193cbb38da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the semaphore initial count value.  <br /></td></tr>
<tr class="separator:a84a0ed04d86929e8bb9e1193cbb38da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734d5093eb06194dbecd13d2c63797a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#gad6dc71df534fae5ff113a4a010511df1">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1semaphore.html#a734d5093eb06194dbecd13d2c63797a8">max_value</a> (void) const</td></tr>
<tr class="memdesc:a734d5093eb06194dbecd13d2c63797a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the semaphore maximum count value.  <br /></td></tr>
<tr class="separator:a734d5093eb06194dbecd13d2c63797a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a3103a84c5e0521c3639306f5879526ba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a> (void) const</td></tr>
<tr class="memdesc:a3103a84c5e0521c3639306f5879526ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get object name.  <br /></td></tr>
<tr class="separator:a3103a84c5e0521c3639306f5879526ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a1456983acc3a56e02cd4a48a220f222c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c">operator new</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a1456983acc3a56e02cd4a48a220f222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a new object instance using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:a1456983acc3a56e02cd4a48a220f222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f709b685919d096e49acb8edefe02f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a35f709b685919d096e49acb8edefe02f">operator new</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:a35f709b685919d096e49acb8edefe02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new object instance.  <br /></td></tr>
<tr class="separator:a35f709b685919d096e49acb8edefe02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27026070d8fd2c51873036cfd1661ce4"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a27026070d8fd2c51873036cfd1661ce4">operator new[]</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a27026070d8fd2c51873036cfd1661ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for an array of new object instances using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:a27026070d8fd2c51873036cfd1661ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#ad415429ae3487ec5ae1258b4d2a5787f">operator new[]</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:ad415429ae3487ec5ae1258b4d2a5787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace an array of new object instances.  <br /></td></tr>
<tr class="separator:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#aef5d78f2ac3f37daf3984758c9e2ddb2">operator delete</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated object instance. using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c29f4a020deee857f22330e0277ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#adc1c29f4a020deee857f22330e0277ed">operator delete[]</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:adc1c29f4a020deee857f22330e0277ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated array of object. instances using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:adc1c29f4a020deee857f22330e0277ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ga6a97b5ca045e295b4928b4741f0d949e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classos_1_1rtos_1_1semaphore_1_1attributes__binary.html">attributes_binary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#ga6a97b5ca045e295b4928b4741f0d949e">initializer_binary</a> { 0 }</td></tr>
<tr class="memdesc:ga6a97b5ca045e295b4928b4741f0d949e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default binary semaphore initialiser.  <br /></td></tr>
<tr class="separator:ga6a97b5ca045e295b4928b4741f0d949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52960bb03444802faaff6fb110156fba"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__cmsis-plus-rtos-semaphore.html#gad6dc71df534fae5ff113a4a010511df1">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#ga52960bb03444802faaff6fb110156fba">max_count_value</a> = 0x7FFF</td></tr>
<tr class="memdesc:ga52960bb03444802faaff6fb110156fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum semaphore value.  <br /></td></tr>
<tr class="separator:ga52960bb03444802faaff6fb110156fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>POSIX compliant <b>semaphore</b>. </p>
<p>Semaphores allow threads and interrupts to synchronise their actions.</p>
<p>A useful way to think of a semaphore as used in the real-world systems is as a record of how many units of a particular resource are available, coupled with operations to safely (i.e., without race conditions) adjust that record as units are required or become free, and, if necessary, wait until a unit of the resource becomes available. Semaphores are a useful tool in the prevention of race conditions; however, their use is by no means a guarantee that a program is free from these problems. Semaphores which allow an arbitrary resource count are called counting semaphores, while semaphores which are restricted to the values 0 and 1 (or locked/unlocked, unavailable/available) are called binary semaphores.</p>
<p>Semaphores should generally be used to synchronise threads with events occurring on interrupts.</p>
<p>For inter-thread synchronisation, to avoid cases of priority inversion, more suitable are mutexes.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <code>sem_t</code> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8h_source.html#l00053">53</a> of file <a class="el" href="os-semaphore_8h_source.html">os-semaphore.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a722459e3f83bb595777960716a15d83f" name="a722459e3f83bb595777960716a15d83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722459e3f83bb595777960716a15d83f">&#9670;&#160;</a></span>semaphore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::semaphore::semaphore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1semaphore_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="group__cmsis-plus-rtos-semaphore.html#ga6a97b5ca045e295b4928b4741f0d949e">initializer_binary</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a semaphore object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise a generic semaphore object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the semaphore attributes shall not be affected. Upon successful initialisation, the state of the semaphore object shall become initialised.</p>
<p>Only the semaphore object itself may be used for performing synchronisation. It is not allowed to make copies of semaphore objects.</p>
<p>In cases where default semaphore attributes are appropriate, the variable <code><a class="el" href="group__cmsis-plus-rtos-semaphore.html#ga6a97b5ca045e295b4928b4741f0d949e" title="Default binary semaphore initialiser.">semaphore::initializer_binary</a></code> can be used to initialise semaphores. The effect shall be equivalent to creating a semaphore object with the default constructor.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_init.html"><code>sem_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8h_source.html#l00737">737</a> of file <a class="el" href="os-semaphore_8h_source.html">os-semaphore.h</a>.</p>

</div>
</div>
<a id="a2716be8bd141fb73bfb338c31459d50a" name="a2716be8bd141fb73bfb338c31459d50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2716be8bd141fb73bfb338c31459d50a">&#9670;&#160;</a></span>semaphore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::semaphore::semaphore </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1semaphore_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="group__cmsis-plus-rtos-semaphore.html#ga6a97b5ca045e295b4928b4741f0d949e">initializer_binary</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a named semaphore object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise a named generic semaphore object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the semaphore attributes shall not be affected. Upon successful initialisation, the state of the semaphore object shall become initialised.</p>
<p>Only the semaphore object itself may be used for performing synchronisation. It is not allowed to make copies of semaphore objects.</p>
<p>In cases where default semaphore attributes are appropriate, the variable <code><a class="el" href="group__cmsis-plus-rtos-semaphore.html#ga6a97b5ca045e295b4928b4741f0d949e" title="Default binary semaphore initialiser.">semaphore::initializer_binary</a></code> can be used to initialise semaphores. The effect shall be equivalent to creating a semaphore object with the default constructor.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_init.html"><code>sem_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8cpp_source.html#l00149">149</a> of file <a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a>.</p>

</div>
</div>
<a id="a4dacfa0176b4286c2784352637396b8d" name="a4dacfa0176b4286c2784352637396b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dacfa0176b4286c2784352637396b8d">&#9670;&#160;</a></span>~semaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::semaphore::~semaphore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct the semaphore object instance. </p>
<p>This destructor shall destroy the semaphore object; the object becomes, in effect, uninitialised. An implementation may cause the destructor to set the object to an invalid value.</p>
<p>It is safe to destroy an initialised semaphore upon which no threads are currently blocked. The effect of destroying a semaphore upon which other threads are currently blocked is undefined.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_destroy.html"><code>sem_destroy()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8cpp_source.html#l00224">224</a> of file <a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a84a0ed04d86929e8bb9e1193cbb38da3" name="a84a0ed04d86929e8bb9e1193cbb38da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a0ed04d86929e8bb9e1193cbb38da3">&#9670;&#160;</a></span>initial_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#gad6dc71df534fae5ff113a4a010511df1">semaphore::count_t</a> os::rtos::semaphore::initial_value </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the semaphore initial count value. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The numeric value set from attributes.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8h_source.html#l00762">762</a> of file <a class="el" href="os-semaphore_8h_source.html">os-semaphore.h</a>.</p>

</div>
</div>
<a id="a734d5093eb06194dbecd13d2c63797a8" name="a734d5093eb06194dbecd13d2c63797a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734d5093eb06194dbecd13d2c63797a8">&#9670;&#160;</a></span>max_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#gad6dc71df534fae5ff113a4a010511df1">semaphore::count_t</a> os::rtos::semaphore::max_value </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the semaphore maximum count value. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The numeric value set from attributes.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8h_source.html#l00775">775</a> of file <a class="el" href="os-semaphore_8h_source.html">os-semaphore.h</a>.</p>

</div>
</div>
<a id="a3103a84c5e0521c3639306f5879526ba" name="a3103a84c5e0521c3639306f5879526ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3103a84c5e0521c3639306f5879526ba">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * os::rtos::internal::object_named::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get object name. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A null terminated string.</dd></dl>
<p>All objects return a non-null string; anonymous objects return <code>"-"</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-decls_8h_source.html#l00760">760</a> of file <a class="el" href="os-decls_8h_source.html">os-decls.h</a>.</p>

</div>
</div>
<a id="aef5d78f2ac3f37daf3984758c9e2ddb2" name="aef5d78f2ac3f37daf3984758c9e2ddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d78f2ac3f37daf3984758c9e2ddb2">&#9670;&#160;</a></span>operator delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated object instance. using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p><em>ptr</em> shall be a null pointer or its value shall be a value returned by an earlier call to the (possibly replaced) <a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c" title="Allocate space for a new object instance using the RTOS system allocator.">operator new()</a> which has not been invalidated by an intervening call to operator delete(void*).</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00134">134</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="adc1c29f4a020deee857f22330e0277ed" name="adc1c29f4a020deee857f22330e0277ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1c29f4a020deee857f22330e0277ed">&#9670;&#160;</a></span>operator delete[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated array of object. instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to array of objects. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by the array form of a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00155">155</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a1456983acc3a56e02cd4a48a220f222c" name="a1456983acc3a56e02cd4a48a220f222c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1456983acc3a56e02cd4a48a220f222c">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for a new object instance using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00056">56</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a35f709b685919d096e49acb8edefe02f" name="a35f709b685919d096e49acb8edefe02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f709b685919d096e49acb8edefe02f">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace a new object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00093">93</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a27026070d8fd2c51873036cfd1661ce4" name="a27026070d8fd2c51873036cfd1661ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27026070d8fd2c51873036cfd1661ce4">&#9670;&#160;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for an array of new object instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00074">74</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="ad415429ae3487ec5ae1258b4d2a5787f" name="ad415429ae3487ec5ae1258b4d2a5787f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad415429ae3487ec5ae1258b4d2a5787f">&#9670;&#160;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace an array of new object instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00110">110</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="af2a81648cf800bfbf76dd31d94b80cd4" name="af2a81648cf800bfbf76dd31d94b80cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a81648cf800bfbf76dd31d94b80cd4">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::semaphore::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1semaphore.html">semaphore</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare semaphores. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The given semaphore is the same as this semaphore. </td></tr>
    <tr><td class="paramname">false</td><td>The semaphores are different.</td></tr>
  </table>
  </dd>
</dl>
<p>Identical semaphores should have the same memory address. </p>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8h_source.html#l00749">749</a> of file <a class="el" href="os-semaphore_8h_source.html">os-semaphore.h</a>.</p>

</div>
</div>
<a id="a466afc9e741ec96dbd1780820789758f" name="a466afc9e741ec96dbd1780820789758f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466afc9e741ec96dbd1780820789758f">&#9670;&#160;</a></span>post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::semaphore::post </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post (unlock) the semaphore. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The semaphore was posted. </td></tr>
    <tr><td class="paramname">EAGAIN</td><td>The maximum count value was exceeded. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The semaphore could not be posted (extension to POSIX).</td></tr>
  </table>
  </dd>
</dl>
<p>Perform a post operation on the semaphore, informing the waiting consumers that one more resource is available. The semaphore count is incremented, up to max_value.</p>
<p>If the semaphore count resulting from this operation is positive, then no threads were blocked waiting for the semaphore to become unlocked.</p>
<p>If the count of the semaphore resulting from this operation is zero, then one of the threads blocked waiting for the semaphore shall be allowed to return successfully from its call to <code><a class="el" href="classos_1_1rtos_1_1semaphore.html#a25bf8989fbd11f6b4add24837a22cd29" title="Lock the semaphore, possibly waiting.">wait()</a></code>.</p>
<p>If the Process Scheduling option is supported, the thread to be unblocked shall be chosen in a manner appropriate to the scheduling policies and parameters in effect for the blocked threads. In the case of the schedulers SCHED_FIFO and SCHED_RR, the highest priority waiting thread shall be unblocked, and if there is more than one highest priority thread blocked waiting for the semaphore, then the highest priority thread that has been waiting the longest shall be unblocked. If the Process Scheduling option is not defined, the choice of a thread to unblock is unspecified. If the scheduling policy is SCHED_SPORADIC, the semantics are as per SCHED_FIFO.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_post.html"><code>sem_post()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Applications using these functions may be subject to priority inversion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8cpp_source.html#l00327">327</a> of file <a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a>.</p>

</div>
</div>
<a id="a3bf4a8cefda24b57821c9cd322b33b19" name="a3bf4a8cefda24b57821c9cd322b33b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf4a8cefda24b57821c9cd322b33b19">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::semaphore::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the semaphore. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The semaphore was reset. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines.</td></tr>
  </table>
  </dd>
</dl>
<p>Reset the counter to the initial value.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8cpp_source.html#l00708">708</a> of file <a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a>.</p>

</div>
</div>
<a id="a19c3e1a3b941763aa51005c767a48067" name="a19c3e1a3b941763aa51005c767a48067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c3e1a3b941763aa51005c767a48067">&#9670;&#160;</a></span>timed_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::semaphore::timed_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos-clock.html#ga149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed wait to lock the semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The calling process successfully performed the semaphore lock operation. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>Invalid timeout (POSIX limits the timeout to 1000 million ns) </td></tr>
    <tr><td class="paramname">ETIMEDOUT</td><td>The semaphore could not be locked before the specified timeout expired. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>Semaphore wait failed (extension to POSIX). </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>A deadlock condition was detected. </td></tr>
    <tr><td class="paramname">EINTR</td><td>The operation was interrupted.</td></tr>
  </table>
  </dd>
</dl>
<p>Try to perform a lock operation; if the semaphore cannot be locked without waiting for another process or thread to unlock the semaphore by performing a <code><a class="el" href="classos_1_1rtos_1_1semaphore.html#a466afc9e741ec96dbd1780820789758f" title="Post (unlock) the semaphore.">post()</a></code> function, this wait shall be terminated when the specified timeout expires.</p>
<p>The timeout shall expire after the number of time units (that is when the value of that clock equals or exceeds (now()+duration). The resolution of the timeout shall be the resolution of the clock on which it is based.</p>
<p>Under no circumstance shall the function fail with a timeout if the semaphore can be locked immediately. The validity of the timeout need not be checked if the semaphore can be locked immediately.</p>
<p>The clock used for timeouts can be specified via the <code>clock</code> attribute. By default, the clock derived from the scheduler timer is used, and the durations are expressed in ticks.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_timedwait.html"><code>sem_timedwait()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). <br  />
Differences from the standard:<ul>
<li>the timeout is not expressed as an absolute time point, but as a relative number of timer ticks (by default, the SysTick clock for CMSIS).</li>
<li>for consistency reasons, EWOULDBLOCK is used, instead of EAGAIN</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd>
<dd>
Applications using these functions may be subject to priority inversion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8cpp_source.html#l00567">567</a> of file <a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a>.</p>

</div>
</div>
<a id="a4c32154fdf817eed5f8ad58bbeacba56" name="a4c32154fdf817eed5f8ad58bbeacba56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c32154fdf817eed5f8ad58bbeacba56">&#9670;&#160;</a></span>try_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::semaphore::try_wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock the semaphore. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The calling process successfully performed the semaphore lock operation. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">EWOULDBLOCK</td><td>The semaphore was already locked. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>Semaphore wait failed (extension to POSIX). </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>A deadlock condition was detected. </td></tr>
    <tr><td class="paramname">EINTR</td><td>The operation was interrupted.</td></tr>
  </table>
  </dd>
</dl>
<p>Tries to perform a lock operation only if the semaphore is currently not locked; that is, if the semaphore value is currently positive it decrements it and returns success. Otherwise, it shall not lock the semaphore.</p>
<p>Upon successful return, the state of the semaphore shall be locked and shall remain locked until the <code><a class="el" href="classos_1_1rtos_1_1semaphore.html#a466afc9e741ec96dbd1780820789758f" title="Post (unlock) the semaphore.">post()</a></code> function is executed and returns successfully.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_trywait.html"><code>sem_trywait()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Applications using these functions may be subject to priority inversion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8cpp_source.html#l00497">497</a> of file <a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a>.</p>

</div>
</div>
<a id="aea52f748c776af2a5e067e50bbae909b" name="aea52f748c776af2a5e067e50bbae909b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea52f748c776af2a5e067e50bbae909b">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cmsis-plus-rtos-semaphore.html#gad6dc71df534fae5ff113a4a010511df1">semaphore::count_t</a> os::rtos::semaphore::value </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the semaphore count value. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The semaphore count value.</dd></dl>
<p>The <code><a class="el" href="classos_1_1rtos_1_1semaphore.html#aea52f748c776af2a5e067e50bbae909b" title="Get the semaphore count value.">value()</a></code> function shall return the value of the semaphore without affecting the state of the semaphore. The value represents an actual semaphore value that occurred at some unspecified time during the call, but it need not be the actual value of the semaphore when it is returned to the calling process. This value reflects the number of available resources.</p>
<p>If the semaphore is locked, then the returned value shall either be set to zero or to a negative number whose absolute value represents the number of processes waiting for the semaphore at some unspecified time during the call.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_getvalue.html"><code>sem_getvalue()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8cpp_source.html#l00689">689</a> of file <a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a>.</p>

</div>
</div>
<a id="a25bf8989fbd11f6b4add24837a22cd29" name="a25bf8989fbd11f6b4add24837a22cd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bf8989fbd11f6b4add24837a22cd29">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::semaphore::wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the semaphore, possibly waiting. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The calling process successfully performed the semaphore lock operation. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>Semaphore wait failed (extension to POSIX). </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>A deadlock condition was detected. </td></tr>
    <tr><td class="paramname">EINTR</td><td>The operation was interrupted.</td></tr>
  </table>
  </dd>
</dl>
<p>Perform a lock operation on the semaphore.</p>
<p>If the current value is positive, it is decremented, and the call returns immediately</p>
<p>If the semaphore value is currently zero, then the calling thread shall not return from the call to <a class="el" href="classos_1_1rtos_1_1semaphore.html#a25bf8989fbd11f6b4add24837a22cd29" title="Lock the semaphore, possibly waiting.">wait()</a> until it either locks the semaphore or the call is interrupted by a signal.</p>
<p>Upon successful return, the state of the semaphore shall be locked and shall remain locked until the <code><a class="el" href="classos_1_1rtos_1_1semaphore.html#a466afc9e741ec96dbd1780820789758f" title="Post (unlock) the semaphore.">post()</a></code> function is executed and returns successfully.</p>
<p>The function is interruptible by the delivery of an external event (signal, thread cancel, etc).</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sem_wait.html"><code>sem_wait()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/semaphore.h.html"><code>&lt;semaphore.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd>
<dd>
Applications using these functions may be subject to priority inversion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-semaphore_8cpp_source.html#l00400">400</a> of file <a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="os-semaphore_8h_source.html">os-semaphore.h</a></li>
<li><a class="el" href="os-semaphore_8cpp_source.html">os-semaphore.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceos.html">os</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos.html">rtos</a></li><li class="navelem"><a class="el" href="classos_1_1rtos_1_1semaphore.html">semaphore</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
