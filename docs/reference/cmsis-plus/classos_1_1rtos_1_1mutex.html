<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>µOS++ IIIe Reference: os::rtos::mutex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-16767008-14', 'auto');
  ga('send', 'pageview');
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="$relpath/../../../.."><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign">
   <div>
     <div id="projectname">µOS++ IIIe Reference
     &#160;<span id="projectnumber">v6.3.15</span>
     </div>
     <div id="projectmotto" class="float:right;">“Perfekt ist nicht gut genug”</div>
     </div>  
   </div>
   <div id="projectbrief">The third edition of µOS++, a POSIX inspired open source system, written in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classos_1_1rtos_1_1mutex.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classos_1_1rtos_1_1mutex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">os::rtos::mutex Class Reference<div class="ingroups"><a class="el" href="group__cmsis-plus-rtos.html">µOS++ RTOS C++ API</a> &raquo; <a class="el" href="group__cmsis-plus-rtos-mutex.html">Mutexes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>POSIX compliant <b>mutex</b>.  
 <a href="classos_1_1rtos_1_1mutex.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="os_8h_source.html">cmsis-plus/rtos/os.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html">os::rtos::internal::object_named_system</a>.</p>

<p>Inherited by <a class="el" href="classos_1_1rtos_1_1mutex__recursive.html">os::rtos::mutex_recursive</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex_1_1attributes.html">attributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex attributes.  <a href="classos_1_1rtos_1_1mutex_1_1attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex_1_1attributes__recursive.html">attributes_recursive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive mutex attributes.  <a href="classos_1_1rtos_1_1mutex_1_1attributes__recursive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos_1_1rtos_1_1mutex_1_1protocol.html">protocol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex protocols.  <a href="structos_1_1rtos_1_1mutex_1_1protocol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos_1_1rtos_1_1mutex_1_1robustness.html">robustness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex robustness.  <a href="structos_1_1rtos_1_1mutex_1_1robustness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html">type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex types.  <a href="structos_1_1rtos_1_1mutex_1_1type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga31a6f2d64eb598ccb0f8152e2bf20504"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga31a6f2d64eb598ccb0f8152e2bf20504">count_t</a> = uint16_t</td></tr>
<tr class="memdesc:ga31a6f2d64eb598ccb0f8152e2bf20504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of variables holding mutex recursion counters.  <a href="group__cmsis-plus-rtos-mutex.html#ga31a6f2d64eb598ccb0f8152e2bf20504">More...</a><br /></td></tr>
<tr class="separator:ga31a6f2d64eb598ccb0f8152e2bf20504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65bfef6cd463aac910d5c93d5828fe7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga65bfef6cd463aac910d5c93d5828fe7f">protocol_t</a> = uint8_t</td></tr>
<tr class="memdesc:ga65bfef6cd463aac910d5c93d5828fe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of variables holding mutex protocols.  <a href="group__cmsis-plus-rtos-mutex.html#ga65bfef6cd463aac910d5c93d5828fe7f">More...</a><br /></td></tr>
<tr class="separator:ga65bfef6cd463aac910d5c93d5828fe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga763c7134e2f479dcc4b21912c0af89c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga763c7134e2f479dcc4b21912c0af89c7">robustness_t</a> = uint8_t</td></tr>
<tr class="memdesc:ga763c7134e2f479dcc4b21912c0af89c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of variables holding mutex robustness.  <a href="group__cmsis-plus-rtos-mutex.html#ga763c7134e2f479dcc4b21912c0af89c7">More...</a><br /></td></tr>
<tr class="separator:ga763c7134e2f479dcc4b21912c0af89c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16cfc618bf9be9be363fc28bd72b3200"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga16cfc618bf9be9be363fc28bd72b3200">type_t</a> = uint8_t</td></tr>
<tr class="memdesc:ga16cfc618bf9be9be363fc28bd72b3200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of variables holding mutex behaviours.  <a href="group__cmsis-plus-rtos-mutex.html#ga16cfc618bf9be9be363fc28bd72b3200">More...</a><br /></td></tr>
<tr class="separator:ga16cfc618bf9be9be363fc28bd72b3200"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructor</div></td></tr>
<tr class="memitem:a5e56aece25fd2a280665afedac2d79f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#a5e56aece25fd2a280665afedac2d79f0">mutex</a> (const <a class="el" href="classos_1_1rtos_1_1mutex_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="group__cmsis-plus-rtos-mutex.html#gab7a76d2ba638380ae88167da73fbd4cf">initializer_normal</a>)</td></tr>
<tr class="memdesc:a5e56aece25fd2a280665afedac2d79f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mutex object instance.  <a href="#a5e56aece25fd2a280665afedac2d79f0">More...</a><br /></td></tr>
<tr class="separator:a5e56aece25fd2a280665afedac2d79f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0c39c37f6ff3b29d112d8a7eae7e5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#afa0c39c37f6ff3b29d112d8a7eae7e5f">mutex</a> (const char *<a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a>, const <a class="el" href="classos_1_1rtos_1_1mutex_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="group__cmsis-plus-rtos-mutex.html#gab7a76d2ba638380ae88167da73fbd4cf">initializer_normal</a>)</td></tr>
<tr class="memdesc:afa0c39c37f6ff3b29d112d8a7eae7e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a named mutex object instance.  <a href="#afa0c39c37f6ff3b29d112d8a7eae7e5f">More...</a><br /></td></tr>
<tr class="separator:afa0c39c37f6ff3b29d112d8a7eae7e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cd0d2915a52d1f6d59867c6288793a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#ad0cd0d2915a52d1f6d59867c6288793a">~mutex</a> ()</td></tr>
<tr class="memdesc:ad0cd0d2915a52d1f6d59867c6288793a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the mutex object instance.  <a href="#ad0cd0d2915a52d1f6d59867c6288793a">More...</a><br /></td></tr>
<tr class="separator:ad0cd0d2915a52d1f6d59867c6288793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:aaefb67373a6f4eca16aada4f1516ce90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#aaefb67373a6f4eca16aada4f1516ce90">operator==</a> (const <a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aaefb67373a6f4eca16aada4f1516ce90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare mutexes.  <a href="#aaefb67373a6f4eca16aada4f1516ce90">More...</a><br /></td></tr>
<tr class="separator:aaefb67373a6f4eca16aada4f1516ce90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a0fd459d4da59662256bbd807b73c263e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#a0fd459d4da59662256bbd807b73c263e">lock</a> (void)</td></tr>
<tr class="memdesc:a0fd459d4da59662256bbd807b73c263e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock/acquire the mutex.  <a href="#a0fd459d4da59662256bbd807b73c263e">More...</a><br /></td></tr>
<tr class="separator:a0fd459d4da59662256bbd807b73c263e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6a0eaa5e19ca9720603439647cb263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#a7d6a0eaa5e19ca9720603439647cb263">try_lock</a> (void)</td></tr>
<tr class="memdesc:a7d6a0eaa5e19ca9720603439647cb263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock/acquire the mutex.  <a href="#a7d6a0eaa5e19ca9720603439647cb263">More...</a><br /></td></tr>
<tr class="separator:a7d6a0eaa5e19ca9720603439647cb263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61911bfedcb48f2ab8314c42a7cb96d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#a61911bfedcb48f2ab8314c42a7cb96d4">timed_lock</a> (<a class="el" href="group__cmsis-plus-rtos-clock.html#ga149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a> timeout)</td></tr>
<tr class="memdesc:a61911bfedcb48f2ab8314c42a7cb96d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed attempt to lock/acquire the mutex.  <a href="#a61911bfedcb48f2ab8314c42a7cb96d4">More...</a><br /></td></tr>
<tr class="separator:a61911bfedcb48f2ab8314c42a7cb96d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb6e546c4dc95c96d8f81aba64638cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb">unlock</a> (void)</td></tr>
<tr class="memdesc:afeb6e546c4dc95c96d8f81aba64638cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock/release the mutex.  <a href="#afeb6e546c4dc95c96d8f81aba64638cb">More...</a><br /></td></tr>
<tr class="separator:afeb6e546c4dc95c96d8f81aba64638cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4934bcd463c94f3e13c6d629bc01debd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cmsis-plus-rtos-thread.html#gaa5d09b05379b4799f126477d0ac29c36">thread::priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#a4934bcd463c94f3e13c6d629bc01debd">prio_ceiling</a> (void) const</td></tr>
<tr class="memdesc:a4934bcd463c94f3e13c6d629bc01debd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority ceiling of a mutex.  <a href="#a4934bcd463c94f3e13c6d629bc01debd">More...</a><br /></td></tr>
<tr class="separator:a4934bcd463c94f3e13c6d629bc01debd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a2c6bbb2d30714f8eee0070e5d0ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#af0a2c6bbb2d30714f8eee0070e5d0ac0">prio_ceiling</a> (<a class="el" href="group__cmsis-plus-rtos-thread.html#gaa5d09b05379b4799f126477d0ac29c36">thread::priority_t</a> prio_ceiling, <a class="el" href="group__cmsis-plus-rtos-thread.html#gaa5d09b05379b4799f126477d0ac29c36">thread::priority_t</a> *old_prio_ceiling=nullptr)</td></tr>
<tr class="memdesc:af0a2c6bbb2d30714f8eee0070e5d0ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the priority ceiling of a mutex.  <a href="#af0a2c6bbb2d30714f8eee0070e5d0ac0">More...</a><br /></td></tr>
<tr class="separator:af0a2c6bbb2d30714f8eee0070e5d0ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9bec2b176e4a9e5714bd8c70bc0aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#ada9bec2b176e4a9e5714bd8c70bc0aab">consistent</a> (void)</td></tr>
<tr class="memdesc:ada9bec2b176e4a9e5714bd8c70bc0aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark mutex as consistent.  <a href="#ada9bec2b176e4a9e5714bd8c70bc0aab">More...</a><br /></td></tr>
<tr class="separator:ada9bec2b176e4a9e5714bd8c70bc0aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfacc498b568dd75fa1d2434ae9b1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classos_1_1rtos_1_1thread.html">thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#adcfacc498b568dd75fa1d2434ae9b1d8">owner</a> (void)</td></tr>
<tr class="memdesc:adcfacc498b568dd75fa1d2434ae9b1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread that owns the mutex.  <a href="#adcfacc498b568dd75fa1d2434ae9b1d8">More...</a><br /></td></tr>
<tr class="separator:adcfacc498b568dd75fa1d2434ae9b1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac067e11063401bed9ac437f21da3b79e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga16cfc618bf9be9be363fc28bd72b3200">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#ac067e11063401bed9ac437f21da3b79e">type</a> (void)</td></tr>
<tr class="memdesc:ac067e11063401bed9ac437f21da3b79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mutex type.  <a href="#ac067e11063401bed9ac437f21da3b79e">More...</a><br /></td></tr>
<tr class="separator:ac067e11063401bed9ac437f21da3b79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb96b1b7ea3c9834abcd6f0ccdc65f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga65bfef6cd463aac910d5c93d5828fe7f">protocol_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#abcb96b1b7ea3c9834abcd6f0ccdc65f2">protocol</a> (void)</td></tr>
<tr class="memdesc:abcb96b1b7ea3c9834abcd6f0ccdc65f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mutex protocol.  <a href="#abcb96b1b7ea3c9834abcd6f0ccdc65f2">More...</a><br /></td></tr>
<tr class="separator:abcb96b1b7ea3c9834abcd6f0ccdc65f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbebf5b630553b522a2c0a886ee1542e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga763c7134e2f479dcc4b21912c0af89c7">robustness_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#abbebf5b630553b522a2c0a886ee1542e">robustness</a> (void)</td></tr>
<tr class="memdesc:abbebf5b630553b522a2c0a886ee1542e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mutex robustness.  <a href="#abbebf5b630553b522a2c0a886ee1542e">More...</a><br /></td></tr>
<tr class="separator:abbebf5b630553b522a2c0a886ee1542e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033e2192e11ca3ba1110f1ec0e29c6e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#a033e2192e11ca3ba1110f1ec0e29c6e3">reset</a> (void)</td></tr>
<tr class="memdesc:a033e2192e11ca3ba1110f1ec0e29c6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the mutex.  <a href="#a033e2192e11ca3ba1110f1ec0e29c6e3">More...</a><br /></td></tr>
<tr class="separator:a033e2192e11ca3ba1110f1ec0e29c6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a3103a84c5e0521c3639306f5879526ba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a> (void) const</td></tr>
<tr class="memdesc:a3103a84c5e0521c3639306f5879526ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get object name.  <a href="#a3103a84c5e0521c3639306f5879526ba">More...</a><br /></td></tr>
<tr class="separator:a3103a84c5e0521c3639306f5879526ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a1456983acc3a56e02cd4a48a220f222c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c">operator new</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a1456983acc3a56e02cd4a48a220f222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a new object instance using the RTOS system allocator.  <a href="#a1456983acc3a56e02cd4a48a220f222c">More...</a><br /></td></tr>
<tr class="separator:a1456983acc3a56e02cd4a48a220f222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f709b685919d096e49acb8edefe02f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a35f709b685919d096e49acb8edefe02f">operator new</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:a35f709b685919d096e49acb8edefe02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new object instance.  <a href="#a35f709b685919d096e49acb8edefe02f">More...</a><br /></td></tr>
<tr class="separator:a35f709b685919d096e49acb8edefe02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27026070d8fd2c51873036cfd1661ce4"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a27026070d8fd2c51873036cfd1661ce4">operator new[]</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a27026070d8fd2c51873036cfd1661ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for an array of new object instances using the RTOS system allocator.  <a href="#a27026070d8fd2c51873036cfd1661ce4">More...</a><br /></td></tr>
<tr class="separator:a27026070d8fd2c51873036cfd1661ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#ad415429ae3487ec5ae1258b4d2a5787f">operator new[]</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:ad415429ae3487ec5ae1258b4d2a5787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace an array of new object instances.  <a href="#ad415429ae3487ec5ae1258b4d2a5787f">More...</a><br /></td></tr>
<tr class="separator:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#aef5d78f2ac3f37daf3984758c9e2ddb2">operator delete</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated object instance. using the RTOS system allocator.  <a href="#aef5d78f2ac3f37daf3984758c9e2ddb2">More...</a><br /></td></tr>
<tr class="separator:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c29f4a020deee857f22330e0277ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#adc1c29f4a020deee857f22330e0277ed">operator delete[]</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:adc1c29f4a020deee857f22330e0277ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated array of object. instances using the RTOS system allocator.  <a href="#adc1c29f4a020deee857f22330e0277ed">More...</a><br /></td></tr>
<tr class="separator:adc1c29f4a020deee857f22330e0277ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:gab7a76d2ba638380ae88167da73fbd4cf"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classos_1_1rtos_1_1mutex_1_1attributes.html">attributes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-mutex.html#gab7a76d2ba638380ae88167da73fbd4cf">initializer_normal</a></td></tr>
<tr class="memdesc:gab7a76d2ba638380ae88167da73fbd4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default normal mutex initialiser.  <a href="group__cmsis-plus-rtos-mutex.html#gab7a76d2ba638380ae88167da73fbd4cf">More...</a><br /></td></tr>
<tr class="separator:gab7a76d2ba638380ae88167da73fbd4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d0eaa13d7ae8e574a110a9c033b414"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classos_1_1rtos_1_1mutex_1_1attributes__recursive.html">attributes_recursive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga63d0eaa13d7ae8e574a110a9c033b414">initializer_recursive</a></td></tr>
<tr class="memdesc:ga63d0eaa13d7ae8e574a110a9c033b414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default recursive mutex initialiser.  <a href="group__cmsis-plus-rtos-mutex.html#ga63d0eaa13d7ae8e574a110a9c033b414">More...</a><br /></td></tr>
<tr class="separator:ga63d0eaa13d7ae8e574a110a9c033b414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7751ed78ef38380bccafa55ac67c1bd"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__cmsis-plus-rtos-mutex.html#ga31a6f2d64eb598ccb0f8152e2bf20504">count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-mutex.html#gaa7751ed78ef38380bccafa55ac67c1bd">max_count</a> = 0xFFFF</td></tr>
<tr class="memdesc:gaa7751ed78ef38380bccafa55ac67c1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant with the maximum value for the recursion counter.  <a href="group__cmsis-plus-rtos-mutex.html#gaa7751ed78ef38380bccafa55ac67c1bd">More...</a><br /></td></tr>
<tr class="separator:gaa7751ed78ef38380bccafa55ac67c1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adb314a48b19f4325e5e69e8a60091fce"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1mutex.html#adb314a48b19f4325e5e69e8a60091fce">thread</a></td></tr>
<tr class="separator:adb314a48b19f4325e5e69e8a60091fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>POSIX compliant <b>mutex</b>. </p>
<p>A synchronisation object used to allow multiple threads to serialise their access to shared data. The name derives from the capability it provides; namely, <b>mutual-exclusion</b>. The thread that has locked a mutex becomes its owner and remains the owner until that same thread unlocks the mutex.</p>
<dl class="section user"><dt>Tradeoff Between Error Checks and Performance Supported</dt><dd></dd></dl>
<p>Many error conditions that can occur are not required to be detected by the implementation in order to let implementations trade off performance versus degree of error checking according to the needs of their specific applications and execution environment. As a general rule, conditions caused by the system (such as insufficient memory) are required to be detected, but conditions caused by an erroneously coded application (such as failing to provide adequate synchronisation to prevent a mutex from being deleted while in use) are specified to result in undefined behaviour.</p>
<p>A wide range of implementations is thus made possible. For example, an implementation intended for application debugging may implement all of the error checks, but an implementation running a single, provably correct application under very tight performance constraints in an embedded computer might implement minimal checks. An implementation might even be provided in two versions, similar to the options that compilers provide: a full-checking, but slower version; and a limited-checking, but faster version. To forbid this optionality would be a disservice to users.</p>
<p>By carefully limiting the use of "undefined behaviour" only to things that an erroneous (badly coded) application might do, and by defining that resource-not-available errors are mandatory, POSIX ensures that a fully-conforming application is portable across the full range of implementations, while not forcing all implementations to add overhead to check for numerous things that a correct program never does. When the behaviour is undefined, no error number is specified to be returned on implementations that do detect the condition. This is because undefined behaviour means anything can happen, which includes returning with any value (which might happen to be a valid, but different, error number). However, since the error number might be useful to application developers when diagnosing problems during application development, a recommendation is made in rationale that implementors should return a particular error number if their implementation does detect the condition.</p>
<dl class="section user"><dt>Static Initialisers</dt><dd></dd></dl>
<p>Providing for static initialisation of statically allocated synchronisation objects allows modules with private static synchronisation variables to avoid runtime initialisation tests and overhead. Furthermore, it simplifies the coding of self-initialising modules. Such modules are common in C libraries, where for various reasons the design calls for self-initialisation instead of requiring an explicit module initialisation function to be called. An example use of static initialisation:</p>
<div class="fragment"><div class="line"><span class="comment">// Construct a normal mutex. Same as using the default constructor.</span></div><div class="line"><a class="code" href="classos_1_1rtos_1_1mutex.html#a5e56aece25fd2a280665afedac2d79f0">mutex</a> mx { <span class="stringliteral">&quot;mx1&quot;</span> };</div><div class="line"></div><div class="line"><span class="comment">// Construct a recursive mutex.</span></div><div class="line">mutex_recursive rmx { <span class="stringliteral">&quot;mx2&quot;</span> };</div></div><!-- fragment --><dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Protected resource.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">  <span class="keywordtype">int</span> count;</div><div class="line">} res_t;</div><div class="line"></div><div class="line">res_t res;</div><div class="line"></div><div class="line"><span class="comment">// Mutex to protect the resource.</span></div><div class="line"><a class="code" href="classos_1_1rtos_1_1mutex.html#a5e56aece25fd2a280665afedac2d79f0">mutex</a> mx;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">func(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Do something</span></div><div class="line"></div><div class="line">  mx.lock();</div><div class="line">  res.count++;</div><div class="line">  mx.unlock();</div><div class="line"></div><div class="line">  <span class="comment">// Do something else.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <code>pthread_mutex_t</code> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8h_source.html#l00053">53</a> of file <a class="el" href="os-mutex_8h_source.html">os-mutex.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5e56aece25fd2a280665afedac2d79f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e56aece25fd2a280665afedac2d79f0">&#9670;&nbsp;</a></span>mutex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::mutex::mutex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1mutex_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="group__cmsis-plus-rtos-mutex.html#gab7a76d2ba638380ae88167da73fbd4cf">initializer_normal</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mutex object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise a mutex object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the mutex attributes shall not be affected. Upon successful initialisation, the state of the mutex object shall become initialised.</p>
<p>Only the mutex object itself may be used for performing synchronisation. It is not allowed to make copies of condition variable objects.</p>
<p>In cases where default mutex attributes are appropriate, the variables <code><a class="el" href="group__cmsis-plus-rtos-mutex.html#gab7a76d2ba638380ae88167da73fbd4cf" title="Default normal mutex initialiser. ">mutex::initializer_normal</a></code> or <code><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga63d0eaa13d7ae8e574a110a9c033b414" title="Default recursive mutex initialiser. ">mutex::initializer_recursive</a></code> can be used to initialise mutex objects. The effect shall be equivalent to creating a mutex object with the default constructor.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html"><code>pthread_mutex_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00431">431</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="afa0c39c37f6ff3b29d112d8a7eae7e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0c39c37f6ff3b29d112d8a7eae7e5f">&#9670;&nbsp;</a></span>mutex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::mutex::mutex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1mutex_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="group__cmsis-plus-rtos-mutex.html#gab7a76d2ba638380ae88167da73fbd4cf">initializer_normal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a named mutex object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise a mutex object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the mutex attributes shall not be affected. Upon successful initialisation, the state of the mutex object shall become initialised.</p>
<p>Only the mutex object itself may be used for performing synchronisation. It is not allowed to make copies of condition variable objects.</p>
<p>In cases where default mutex attributes are appropriate, the variables <code><a class="el" href="group__cmsis-plus-rtos-mutex.html#gab7a76d2ba638380ae88167da73fbd4cf" title="Default normal mutex initialiser. ">mutex::initializer_normal</a></code> or <code><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga63d0eaa13d7ae8e574a110a9c033b414" title="Default recursive mutex initialiser. ">mutex::initializer_recursive</a></code> can be used to initialise mutex objects. The effect shall be equivalent to creating a mutex object with the default constructor.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html"><code>pthread_mutex_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00465">465</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="ad0cd0d2915a52d1f6d59867c6288793a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cd0d2915a52d1f6d59867c6288793a">&#9670;&nbsp;</a></span>~mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::mutex::~mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct the mutex object instance. </p>
<p>This destructor shall destroy the mutex object; the object becomes, in effect, uninitialised. An implementation may cause the destructor to set the object to an invalid value.</p>
<p>It shall be safe to destroy an initialised mutex that is unlocked. Attempting to destroy a locked mutex results in undefined behaviour (for example it may trigger an assert).</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_destroy.html"><code>pthread_mutex_destroy()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00525">525</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ada9bec2b176e4a9e5714bd8c70bc0aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9bec2b176e4a9e5714bd8c70bc0aab">&#9670;&nbsp;</a></span>consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::mutex::consistent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark mutex as consistent. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was marked as consistent. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mutex object referenced by mutex is not robust or does not protect an inconsistent state.</td></tr>
  </table>
  </dd>
</dl>
<p>If the robust mutex is in an inconsistent state, the <code><a class="el" href="classos_1_1rtos_1_1mutex.html#ada9bec2b176e4a9e5714bd8c70bc0aab" title="Mark mutex as consistent. ">consistent()</a></code> function can be used to mark the state protected by the mutex referenced by mutex as consistent again.</p>
<p>If an owner of a robust mutex terminates while holding the mutex, the mutex becomes inconsistent and the next thread that acquires the mutex lock shall be notified of the state by the return value <code>EOWNERDEAD</code>. In this case, the mutex does not become normally usable again until the state is marked consistent.</p>
<p>If the thread which acquired the mutex lock with the return value <code>EOWNERDEAD</code> terminates before calling either <code><a class="el" href="classos_1_1rtos_1_1mutex.html#ada9bec2b176e4a9e5714bd8c70bc0aab" title="Mark mutex as consistent. ">consistent()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb" title="Unlock/release the mutex. ">unlock()</a></code>, the next thread that acquires the mutex lock shall be notified about the state of the mutex by the return value <code>EOWNERDEAD</code>.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_consistent.html"><code>pthread_mutex_consistent()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l01417">1417</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="a0fd459d4da59662256bbd807b73c263e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd459d4da59662256bbd807b73c263e">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::mutex::lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock/acquire the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was locked. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable.. </td></tr>
    <tr><td class="paramname">EAGAIN</td><td>The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mutex was created with the protocol attribute having the value <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1protocol.html#a0a3a2506459afaf7cb613aaf1fd875a9aebac25e02252bdd4f038dd200b2ef7cb" title="Execute at the highest priority. ">mutex::protocol::protect</a></code> and the calling thread's priority is higher than the mutex's current priority ceiling. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>The mutex type is <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9a77c021f70c077e034edf3044329c2d26" title="Check mutex behaviour. ">mutex::type::errorcheck</a></code> and the current thread already owns the mutex.</td></tr>
  </table>
  </dd>
</dl>
<p>If the mutex is free, lock it. If the mutex is already locked by another thread, the calling thread shall block until the mutex becomes available. This operation shall return with the mutex object referenced by mutex in the locked state with the calling thread as its owner. If a thread attempts to relock a mutex that it has already locked, <code><a class="el" href="classos_1_1rtos_1_1mutex.html#a0fd459d4da59662256bbd807b73c263e" title="Lock/acquire the mutex. ">lock()</a></code> shall behave as described in the <b>Relock</b> column of the following table. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, <code><a class="el" href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb" title="Unlock/release the mutex. ">unlock()</a></code> shall behave as described in the <b>Unlock When Not Owner</b> column of the following table.</p>
<table class="doxtable">
<tr>
<th>Mutex Type </th><th>Robustness </th><th>Relock </th><th>Unlock When Not Owner  </th></tr>
<tr>
<td>normal </td><td>non-robust </td><td>deadlock </td><td>undefined behaviour </td></tr>
<tr>
<td>normal </td><td>robust </td><td>deadlock </td><td>error </td></tr>
<tr>
<td>errorcheck </td><td>either </td><td>error </td><td>error </td></tr>
<tr>
<td>recursive </td><td>either </td><td>recursive </td><td>error </td></tr>
<tr>
<td>default </td><td>non-robust </td><td>undefined </td><td>undefined behaviour </td></tr>
<tr>
<td>default </td><td>robust </td><td>undefined </td><td>error </td></tr>
</table>
<p>Where the table indicates recursive behaviour, the mutex shall maintain the concept of a lock count. When a thread successfully acquires a mutex for the first time, the lock count shall be set to one. Every time a thread relocks this mutex, the lock count shall be incremented by one. Each time the thread unlocks the mutex, the lock count shall be decremented by one. When the lock count reaches zero, the mutex shall become available for other threads to acquire.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html"><code>pthread_mutex_lock()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l00918">918</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="a3103a84c5e0521c3639306f5879526ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3103a84c5e0521c3639306f5879526ba">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * os::rtos::internal::object_named::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get object name. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A null terminated string.</dd></dl>
<p>All objects return a non-null string; anonymous objects return <code>"-"</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-decls_8h_source.html#l00760">760</a> of file <a class="el" href="os-decls_8h_source.html">os-decls.h</a>.</p>

</div>
</div>
<a id="aef5d78f2ac3f37daf3984758c9e2ddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d78f2ac3f37daf3984758c9e2ddb2">&#9670;&nbsp;</a></span>operator delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated object instance. using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p><em>ptr</em> shall be a null pointer or its value shall be a value returned by an earlier call to the (possibly replaced) <a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c" title="Allocate space for a new object instance using the RTOS system allocator. ">operator new()</a> which has not been invalidated by an intervening call to <a class="el" href="group__cmsis-plus-rtos-memres.html#gafa145befcf5e7b83424408ca503c8637" title="Deallocate the dynamically allocated object instance. ">operator delete(void*)</a>.</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00134">134</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="adc1c29f4a020deee857f22330e0277ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1c29f4a020deee857f22330e0277ed">&#9670;&nbsp;</a></span>operator delete[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated array of object. instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to array of objects. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by the array form of a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00155">155</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a1456983acc3a56e02cd4a48a220f222c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1456983acc3a56e02cd4a48a220f222c">&#9670;&nbsp;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for a new object instance using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00056">56</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a35f709b685919d096e49acb8edefe02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f709b685919d096e49acb8edefe02f">&#9670;&nbsp;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace a new object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00093">93</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a27026070d8fd2c51873036cfd1661ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27026070d8fd2c51873036cfd1661ce4">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for an array of new object instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00074">74</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="ad415429ae3487ec5ae1258b4d2a5787f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad415429ae3487ec5ae1258b4d2a5787f">&#9670;&nbsp;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace an array of new object instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00110">110</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="aaefb67373a6f4eca16aada4f1516ce90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefb67373a6f4eca16aada4f1516ce90">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::mutex::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare mutexes. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The given mutex is the same as this mutex. </td></tr>
    <tr><td class="paramname">false</td><td>The mutexes are different.</td></tr>
  </table>
  </dd>
</dl>
<p>Identical mutexes should have the same memory address. </p>

<p class="definition">Definition at line <a class="el" href="os-mutex_8h_source.html#l00833">833</a> of file <a class="el" href="os-mutex_8h_source.html">os-mutex.h</a>.</p>

</div>
</div>
<a id="adcfacc498b568dd75fa1d2434ae9b1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfacc498b568dd75fa1d2434ae9b1d8">&#9670;&nbsp;</a></span>owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1thread.html">thread</a> * os::rtos::mutex::owner </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the thread that owns the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to thread or <code>nullptr</code> if not owned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8h_source.html#l00844">844</a> of file <a class="el" href="os-mutex_8h_source.html">os-mutex.h</a>.</p>

</div>
</div>
<a id="a4934bcd463c94f3e13c6d629bc01debd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4934bcd463c94f3e13c6d629bc01debd">&#9670;&nbsp;</a></span>prio_ceiling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cmsis-plus-rtos-thread.html#gaa5d09b05379b4799f126477d0ac29c36">thread::priority_t</a> os::rtos::mutex::prio_ceiling </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority ceiling of a mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The priority ceiling.</dd></dl>
<p>Return the current priority ceiling of the mutex.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_getprioceiling.html"><code>pthread_mutex_getprioceiling()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l01310">1310</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="af0a2c6bbb2d30714f8eee0070e5d0ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a2c6bbb2d30714f8eee0070e5d0ac0">&#9670;&nbsp;</a></span>prio_ceiling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::mutex::prio_ceiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos-thread.html#gaa5d09b05379b4799f126477d0ac29c36">thread::priority_t</a>&#160;</td>
          <td class="paramname"><em>prio_ceiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos-thread.html#gaa5d09b05379b4799f126477d0ac29c36">thread::priority_t</a> *&#160;</td>
          <td class="paramname"><em>old_prio_ceiling</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the priority ceiling of a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prio_ceiling</td><td>new priority. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">old_prio_ceiling</td><td>pointer to location where to store the previous priority; may be <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The priority was changed. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable.. </td></tr>
    <tr><td class="paramname">EAGAIN</td><td>The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mutex was created with the protocol attribute having the value <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1protocol.html#a0a3a2506459afaf7cb613aaf1fd875a9aebac25e02252bdd4f038dd200b2ef7cb" title="Execute at the highest priority. ">mutex::protocol::protect</a></code> and the calling thread's priority is higher than the mutex's current priority ceiling. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>The mutex type is <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9a77c021f70c077e034edf3044329c2d26" title="Check mutex behaviour. ">mutex::type::errorcheck</a></code> and the current thread already owns the mutex.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to lock the mutex as if by a call to <code><a class="el" href="classos_1_1rtos_1_1mutex.html#a0fd459d4da59662256bbd807b73c263e" title="Lock/acquire the mutex. ">lock()</a></code>, except that the process of locking the mutex need not adhere to the priority protect protocol. On acquiring the mutex it shall change the mutex's priority ceiling and then release the mutex as if by a call to <code><a class="el" href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb" title="Unlock/release the mutex. ">unlock()</a></code>. When the change is successful, the previous value of the priority ceiling shall be returned in <code>old_prio_ceiling</code>.</p>
<p>If <code><a class="el" href="classos_1_1rtos_1_1mutex.html#a4934bcd463c94f3e13c6d629bc01debd" title="Get the priority ceiling of a mutex. ">prio_ceiling()</a></code> function fails, the mutex priority ceiling shall not be changed.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_setprioceiling.html"><code>pthread_mutex_setprioceiling()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l01351">1351</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="abcb96b1b7ea3c9834abcd6f0ccdc65f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb96b1b7ea3c9834abcd6f0ccdc65f2">&#9670;&nbsp;</a></span>protocol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga65bfef6cd463aac910d5c93d5828fe7f">mutex::protocol_t</a> <a class="el" href="structos_1_1rtos_1_1mutex_1_1protocol.html">os::rtos::mutex::protocol</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mutex protocol. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer encoding the <a class="el" href="structos_1_1rtos_1_1mutex_1_1protocol.html">mutex::protocol</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8h_source.html#l00866">866</a> of file <a class="el" href="os-mutex_8h_source.html">os-mutex.h</a>.</p>

</div>
</div>
<a id="a033e2192e11ca3ba1110f1ec0e29c6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033e2192e11ca3ba1110f1ec0e29c6e3">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::mutex::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was reset.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the mutex to the state right after creation. If there were threads waiting for this mutex, wakeup all, then clear the waiting list.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l01454">1454</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="abbebf5b630553b522a2c0a886ee1542e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbebf5b630553b522a2c0a886ee1542e">&#9670;&nbsp;</a></span>robustness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga763c7134e2f479dcc4b21912c0af89c7">mutex::robustness_t</a> <a class="el" href="structos_1_1rtos_1_1mutex_1_1robustness.html">os::rtos::mutex::robustness</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mutex robustness. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer encoding the <a class="el" href="structos_1_1rtos_1_1mutex_1_1robustness.html">mutex::robustness</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8h_source.html#l00877">877</a> of file <a class="el" href="os-mutex_8h_source.html">os-mutex.h</a>.</p>

</div>
</div>
<a id="a61911bfedcb48f2ab8314c42a7cb96d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61911bfedcb48f2ab8314c42a7cb96d4">&#9670;&nbsp;</a></span>timed_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::mutex::timed_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos-clock.html#ga149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed attempt to lock/acquire the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to wait, in clock units (ticks or seconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was locked. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ETIMEDOUT</td><td>The mutex could not be locked before the specified timeout expired. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable. </td></tr>
    <tr><td class="paramname">EAGAIN</td><td>The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded. </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>The mutex type is <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9a77c021f70c077e034edf3044329c2d26" title="Check mutex behaviour. ">mutex::type::errorcheck</a></code> and the current thread already owns the mutex. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The process or thread would have blocked, and the timeout parameter is invalid. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.</td></tr>
  </table>
  </dd>
</dl>
<p>If the mutex is already locked, the calling thread shall block until the mutex becomes available as in the <code><a class="el" href="classos_1_1rtos_1_1mutex.html#a0fd459d4da59662256bbd807b73c263e" title="Lock/acquire the mutex. ">lock()</a></code> function. If the mutex cannot be locked without waiting for another thread to unlock the mutex, this wait shall be terminated when the specified timeout expires.</p>
<p>The timeout shall expire after the number of time units (that is when the value of that clock equals or exceeds (now()+duration). The resolution of the timeout shall be the resolution of the clock on which it is based.</p>
<p>Under no circumstance shall the function fail with a timeout if the mutex can be locked immediately. The validity of the timeout need not be checked if the mutex can be locked immediately.</p>
<p>The clock used for timeouts can be specified via the <code>clock</code> attribute. By default, the clock derived from the scheduler timer is used, and the durations are expressed in ticks.</p>
<p>As a consequence of the priority inheritance rules (for mutexes initialized with <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1protocol.html#a0a3a2506459afaf7cb613aaf1fd875a9ac288479da49bf12ecbb0e31cb4d5fde4" title="Inherit priority from highest priority thread. ">mutex::protocol::inherit</a></code>), if a timed mutex wait is terminated because its timeout expires, the priority of the owner of the mutex shall be adjusted as necessary to reflect the fact that this thread is no longer among the threads waiting for the mutex.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_timedlock.html"><code>pthread_mutex_timedlock()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). <br />
Differences from the standard:<ul>
<li>the timeout is not expressed as an absolute time point, but as a relative number of timer ticks (by default, the SysTick clock for Cortex-M).</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l01115">1115</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="a7d6a0eaa5e19ca9720603439647cb263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6a0eaa5e19ca9720603439647cb263">&#9670;&nbsp;</a></span>try_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::mutex::try_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock/acquire the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was locked. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable.. </td></tr>
    <tr><td class="paramname">EAGAIN</td><td>The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mutex was created with the protocol attribute having the value <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1protocol.html#a0a3a2506459afaf7cb613aaf1fd875a9aebac25e02252bdd4f038dd200b2ef7cb" title="Execute at the highest priority. ">mutex::protocol::protect</a></code> and the calling thread's priority is higher than the mutex's current priority ceiling. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
    <tr><td class="paramname">EDEADLK</td><td>The mutex type is <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9a77c021f70c077e034edf3044329c2d26" title="Check mutex behaviour. ">mutex::type::errorcheck</a></code> and the current thread already owns the mutex. </td></tr>
    <tr><td class="paramname">EWOULDBLOCK</td><td>The mutex could not be acquired because it was already locked.</td></tr>
  </table>
  </dd>
</dl>
<p>Try to lock the mutex as <code><a class="el" href="classos_1_1rtos_1_1mutex.html#a0fd459d4da59662256bbd807b73c263e" title="Lock/acquire the mutex. ">lock()</a></code>, except that if the mutex is currently locked (by any thread, including the current thread), the call shall return immediately. If the mutex type is <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9af017289ec993ae32eaf61107612b857f" title="Recursive mutex behaviour. ">mutex::type::recursive</a></code> and the mutex is currently owned by the calling thread, the mutex lock count shall be incremented by one and the <code><a class="el" href="classos_1_1rtos_1_1mutex.html#a7d6a0eaa5e19ca9720603439647cb263" title="Try to lock/acquire the mutex. ">try_lock()</a></code> function shall immediately return success.</p>
<p>If the mutex is robust and the owning thread terminated while holding the mutex lock, a call to <code><a class="el" href="classos_1_1rtos_1_1mutex.html#a7d6a0eaa5e19ca9720603439647cb263" title="Try to lock/acquire the mutex. ">try_lock()</a></code> may return the error value <code>EOWNERDEAD</code>. In these cases, the mutex is locked by the thread but the state it protects is marked as inconsistent. The application should ensure that the state is made consistent for reuse and when that is complete call <code><a class="el" href="classos_1_1rtos_1_1mutex.html#ada9bec2b176e4a9e5714bd8c70bc0aab" title="Mark mutex as consistent. ">consistent()</a></code>. If the application is unable to recover the state, it should unlock the mutex without a prior call to <code><a class="el" href="classos_1_1rtos_1_1mutex.html#ada9bec2b176e4a9e5714bd8c70bc0aab" title="Mark mutex as consistent. ">consistent()</a></code>, after which the mutex is marked permanently unusable.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_trylock.html"><code>pthread_mutex_trylock()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). <br />
Differences from the standard:<ul>
<li>for consistency reasons, EWOULDBLOCK is used, instead of EBUSY</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l01039">1039</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<a id="ac067e11063401bed9ac437f21da3b79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac067e11063401bed9ac437f21da3b79e">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cmsis-plus-rtos-mutex.html#ga16cfc618bf9be9be363fc28bd72b3200">mutex::type_t</a> <a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html">os::rtos::mutex::type</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mutex type. </p>
<dl class="section return"><dt>Returns</dt><dd>An integer encoding the <a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html">mutex::type</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8h_source.html#l00855">855</a> of file <a class="el" href="os-mutex_8h_source.html">os-mutex.h</a>.</p>

</div>
</div>
<a id="afeb6e546c4dc95c96d8f81aba64638cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb6e546c4dc95c96d8f81aba64638cb">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::mutex::unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock/release the mutex. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred. ">result::ok</a></td><td>The mutex was unlocked. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routine; the mutex type is <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9a77c021f70c077e034edf3044329c2d26" title="Check mutex behaviour. ">mutex::type::errorcheck</a></code> or <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9af017289ec993ae32eaf61107612b857f" title="Recursive mutex behaviour. ">mutex::type::recursive</a></code>, or the mutex is a robust mutex, and the current thread does not own the mutex. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The recursive mutex whose oner died was not marked <code><a class="el" href="classos_1_1rtos_1_1mutex.html#ada9bec2b176e4a9e5714bd8c70bc0aab" title="Mark mutex as consistent. ">consistent()</a></code> before <code><a class="el" href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb" title="Unlock/release the mutex. ">unlock()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The manner in which a mutex is released is dependent upon the mutex's type attribute. If there are threads blocked on the mutex object referenced by mutex when <code><a class="el" href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb" title="Unlock/release the mutex. ">unlock()</a></code> is called, resulting in the mutex becoming available, the scheduling policy shall determine which thread shall acquire the mutex.</p>
<p>In the case of <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9af017289ec993ae32eaf61107612b857f" title="Recursive mutex behaviour. ">mutex::type::recursive</a></code> mutexes, the mutex shall become available when the count reaches zero and the calling thread no longer has any locks on this mutex.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_unlock.html"><code>pthread_mutex_unlock()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mutex_8cpp_source.html#l01275">1275</a> of file <a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="adb314a48b19f4325e5e69e8a60091fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb314a48b19f4325e5e69e8a60091fce">&#9670;&nbsp;</a></span>thread</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classos_1_1rtos_1_1thread.html">thread</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="os-mutex_8h_source.html#l00601">601</a> of file <a class="el" href="os-mutex_8h_source.html">os-mutex.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cmsis-plus/rtos/<a class="el" href="os-mutex_8h_source.html">os-mutex.h</a></li>
<li>src/rtos/<a class="el" href="os-mutex_8cpp_source.html">os-mutex.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceos.html">os</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos.html">rtos</a></li><li class="navelem"><a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
