<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>µOS++ IIIe Reference: os::rtos::memory_pool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="common-custom.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<!-- Awesome Theme Begin -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
DoxygenAwesomeInteractiveToc.init()
DoxygenAwesomeTabs.init()
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9T84WD3CK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9T84WD3CK');
</script>
<!-- Awesome Theme End -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><a href="$relpath/../../../"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign">
   <div id="projectname">µOS++ IIIe Reference<span id="projectnumber">&#160;6.3.17</span>
   </div>
   <div id="projectbrief">The third edition of µOS++, a POSIX inspired open source framework, written in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classos_1_1rtos_1_1memory__pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classos_1_1rtos_1_1memory__pool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">os::rtos::memory_pool Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Synchronised <b>memory pool</b>, using the default RTOS allocator.  
 <a href="classos_1_1rtos_1_1memory__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="os_8h_source.html">cmsis-plus/rtos/os.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for os::rtos::memory_pool:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classos_1_1rtos_1_1memory__pool.png" usemap="#os::rtos::memory_5Fpool_map" alt=""/>
  <map id="os::rtos::memory_5Fpool_map" name="os::rtos::memory_5Fpool_map">
<area href="classos_1_1rtos_1_1internal_1_1object__named__system.html" title="Base class for named system objects." alt="os::rtos::internal::object_named_system" shape="rect" coords="384,56,758,80"/>
<area href="classos_1_1rtos_1_1internal_1_1object__named.html" title="Base class for named objects." alt="os::rtos::internal::object_named" shape="rect" coords="384,0,758,24"/>
<area href="classos_1_1rtos_1_1memory__pool__allocated.html" alt="os::rtos::memory_pool_allocated&lt; memory::allocator&lt; void * &gt; &gt;" shape="rect" coords="0,168,374,192"/>
<area href="classos_1_1rtos_1_1memory__pool__allocated.html" title="Template of a synchronised memory pool with allocator." alt="os::rtos::memory_pool_allocated&lt; Allocator &gt;" shape="rect" coords="384,168,758,192"/>
<area href="classos_1_1rtos_1_1memory__pool__inclusive.html" title="Template of a synchronised memory pool with block type and local storage." alt="os::rtos::memory_pool_inclusive&lt; T, N &gt;" shape="rect" coords="768,168,1142,192"/>
<area href="classos_1_1rtos_1_1memory__pool__typed.html" title="Template of a synchronised memory pool with block type and allocator." alt="os::rtos::memory_pool_typed&lt; T, Allocator &gt;" shape="rect" coords="384,224,758,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool_1_1arena.html">arena</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for a memory pool.  <a href="classos_1_1rtos_1_1memory__pool_1_1arena.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool_1_1attributes.html">attributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory pool attributes.  <a href="classos_1_1rtos_1_1memory__pool_1_1attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ef5fc603da1b3dfd918ca4d03f8ff97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a> = <a class="el" href="group__cmsis-plus-rtos-memres.html#gac00e47b1a65850b96de7c9fe0e938da1">memory::allocator</a>&lt; <a class="el" href="classos_1_1rtos_1_1thread_1_1stack.html#ab4cbbaaaf2f0a91dcc9a7cc42b7f8b98">thread::stack::allocation_element_t</a> &gt;</td></tr>
<tr class="memdesc:a5ef5fc603da1b3dfd918ca4d03f8ff97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default RTOS allocator.  <br /></td></tr>
<tr class="separator:a5ef5fc603da1b3dfd918ca4d03f8ff97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2906df850164ea47bd55d45a254f6699"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a2906df850164ea47bd55d45a254f6699">size_t</a> = uint16_t</td></tr>
<tr class="memdesc:a2906df850164ea47bd55d45a254f6699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of memory pool size storage.  <br /></td></tr>
<tr class="separator:a2906df850164ea47bd55d45a254f6699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada288312b54cc038fcdc144ed91c53ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada288312b54cc038fcdc144ed91c53ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#ada288312b54cc038fcdc144ed91c53ef">compute_allocated_size_bytes</a> (std::size_t blocks, std::size_t block_size_bytes)</td></tr>
<tr class="memdesc:ada288312b54cc038fcdc144ed91c53ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculator for pool storage requirements.  <br /></td></tr>
<tr class="separator:ada288312b54cc038fcdc144ed91c53ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructor</div></td></tr>
<tr class="memitem:a2170a2c21e7c9c5234a111ffedecd9ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a2170a2c21e7c9c5234a111ffedecd9ce">memory_pool</a> (std::size_t blocks, std::size_t block_size_bytes, const <a class="el" href="classos_1_1rtos_1_1memory__pool_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="classos_1_1rtos_1_1memory__pool.html#a7fd442f85898940215d53d32e7a4eee7">initializer</a>, const <a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a> &amp;allocator=<a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a>())</td></tr>
<tr class="memdesc:a2170a2c21e7c9c5234a111ffedecd9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a memory pool object instance.  <br /></td></tr>
<tr class="separator:a2170a2c21e7c9c5234a111ffedecd9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60784bab43302b4e7bfc6b2964598d3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a60784bab43302b4e7bfc6b2964598d3e">memory_pool</a> (const char *<a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a>, std::size_t blocks, std::size_t block_size_bytes, const <a class="el" href="classos_1_1rtos_1_1memory__pool_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="classos_1_1rtos_1_1memory__pool.html#a7fd442f85898940215d53d32e7a4eee7">initializer</a>, const <a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a> &amp;allocator=<a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a>())</td></tr>
<tr class="memdesc:a60784bab43302b4e7bfc6b2964598d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a named memory pool object instance.  <br /></td></tr>
<tr class="separator:a60784bab43302b4e7bfc6b2964598d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9744239d3f89c9a63a4156e43175884"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#ae9744239d3f89c9a63a4156e43175884">~memory_pool</a> ()</td></tr>
<tr class="memdesc:ae9744239d3f89c9a63a4156e43175884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the memory pool object instance.  <br /></td></tr>
<tr class="separator:ae9744239d3f89c9a63a4156e43175884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:aef89826c91bc8b7e7b9d08644bcd0098"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#aef89826c91bc8b7e7b9d08644bcd0098">operator==</a> (const <a class="el" href="classos_1_1rtos_1_1memory__pool.html">memory_pool</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aef89826c91bc8b7e7b9d08644bcd0098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare memory pools.  <br /></td></tr>
<tr class="separator:aef89826c91bc8b7e7b9d08644bcd0098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a398b56100a97f150fb31bcc781ced974"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a398b56100a97f150fb31bcc781ced974">alloc</a> (void)</td></tr>
<tr class="memdesc:a398b56100a97f150fb31bcc781ced974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block.  <br /></td></tr>
<tr class="separator:a398b56100a97f150fb31bcc781ced974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3755c8ce8f934469047b735209ab58b3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a3755c8ce8f934469047b735209ab58b3">try_alloc</a> (void)</td></tr>
<tr class="memdesc:a3755c8ce8f934469047b735209ab58b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to allocate a memory block.  <br /></td></tr>
<tr class="separator:a3755c8ce8f934469047b735209ab58b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368b3eeaa2c28df26b6f3970fd209f3b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a368b3eeaa2c28df26b6f3970fd209f3b">timed_alloc</a> (<a class="el" href="classos_1_1rtos_1_1clock.html#a149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a> timeout)</td></tr>
<tr class="memdesc:a368b3eeaa2c28df26b6f3970fd209f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block with timeout.  <br /></td></tr>
<tr class="separator:a368b3eeaa2c28df26b6f3970fd209f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95efd50d23b62a19590750f1ff07c063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a95efd50d23b62a19590750f1ff07c063">free</a> (void *block)</td></tr>
<tr class="memdesc:a95efd50d23b62a19590750f1ff07c063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory block.  <br /></td></tr>
<tr class="separator:a95efd50d23b62a19590750f1ff07c063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6611d00923116927509330745999c02e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a6611d00923116927509330745999c02e">capacity</a> (void) const</td></tr>
<tr class="memdesc:a6611d00923116927509330745999c02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory pool capacity.  <br /></td></tr>
<tr class="separator:a6611d00923116927509330745999c02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3f1aa4c42b7b2a94b536b8e07bb381"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a8c3f1aa4c42b7b2a94b536b8e07bb381">count</a> (void) const</td></tr>
<tr class="memdesc:a8c3f1aa4c42b7b2a94b536b8e07bb381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get blocks count.  <br /></td></tr>
<tr class="separator:a8c3f1aa4c42b7b2a94b536b8e07bb381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387abd2e85b6365e4f2606333502d605"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a387abd2e85b6365e4f2606333502d605">block_size</a> (void) const</td></tr>
<tr class="memdesc:a387abd2e85b6365e4f2606333502d605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block size.  <br /></td></tr>
<tr class="separator:a387abd2e85b6365e4f2606333502d605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1a85ba53c3d3c39ed992a1f4c7c285"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a3f1a85ba53c3d3c39ed992a1f4c7c285">empty</a> (void) const</td></tr>
<tr class="memdesc:a3f1a85ba53c3d3c39ed992a1f4c7c285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the memory pool is empty.  <br /></td></tr>
<tr class="separator:a3f1a85ba53c3d3c39ed992a1f4c7c285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76b6ad1dc90e2869a8c35949b551576"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#af76b6ad1dc90e2869a8c35949b551576">full</a> (void) const</td></tr>
<tr class="memdesc:af76b6ad1dc90e2869a8c35949b551576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the memory pool is full.  <br /></td></tr>
<tr class="separator:af76b6ad1dc90e2869a8c35949b551576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac764ac06d8a23bc517ea0785caccf350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#ac764ac06d8a23bc517ea0785caccf350">reset</a> (void)</td></tr>
<tr class="memdesc:ac764ac06d8a23bc517ea0785caccf350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the memory pool.  <br /></td></tr>
<tr class="separator:ac764ac06d8a23bc517ea0785caccf350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fde03a7e551f6d28f12a1e21d10e87"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#aa1fde03a7e551f6d28f12a1e21d10e87">pool</a> (void)</td></tr>
<tr class="memdesc:aa1fde03a7e551f6d28f12a1e21d10e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pool storage address.  <br /></td></tr>
<tr class="separator:aa1fde03a7e551f6d28f12a1e21d10e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a3103a84c5e0521c3639306f5879526ba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a> (void) const</td></tr>
<tr class="memdesc:a3103a84c5e0521c3639306f5879526ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get object name.  <br /></td></tr>
<tr class="separator:a3103a84c5e0521c3639306f5879526ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a1456983acc3a56e02cd4a48a220f222c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c">operator new</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a1456983acc3a56e02cd4a48a220f222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a new object instance using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:a1456983acc3a56e02cd4a48a220f222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f709b685919d096e49acb8edefe02f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a35f709b685919d096e49acb8edefe02f">operator new</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:a35f709b685919d096e49acb8edefe02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new object instance.  <br /></td></tr>
<tr class="separator:a35f709b685919d096e49acb8edefe02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27026070d8fd2c51873036cfd1661ce4"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a27026070d8fd2c51873036cfd1661ce4">operator new[]</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a27026070d8fd2c51873036cfd1661ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for an array of new object instances using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:a27026070d8fd2c51873036cfd1661ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#ad415429ae3487ec5ae1258b4d2a5787f">operator new[]</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:ad415429ae3487ec5ae1258b4d2a5787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace an array of new object instances.  <br /></td></tr>
<tr class="separator:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#aef5d78f2ac3f37daf3984758c9e2ddb2">operator delete</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated object instance. using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c29f4a020deee857f22330e0277ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#adc1c29f4a020deee857f22330e0277ed">operator delete[]</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:adc1c29f4a020deee857f22330e0277ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated array of object. instances using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:adc1c29f4a020deee857f22330e0277ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7fd442f85898940215d53d32e7a4eee7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classos_1_1rtos_1_1memory__pool_1_1attributes.html">attributes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a7fd442f85898940215d53d32e7a4eee7">initializer</a></td></tr>
<tr class="memdesc:a7fd442f85898940215d53d32e7a4eee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default memory pool initialiser.  <br /></td></tr>
<tr class="separator:a7fd442f85898940215d53d32e7a4eee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25abdce615f4418c120dfdaa66db582e"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classos_1_1rtos_1_1memory__pool.html#a2906df850164ea47bd55d45a254f6699">memory_pool::size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a25abdce615f4418c120dfdaa66db582e">max_size</a></td></tr>
<tr class="memdesc:a25abdce615f4418c120dfdaa66db582e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum pool size.  <br /></td></tr>
<tr class="separator:a25abdce615f4418c120dfdaa66db582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Synchronised <b>memory pool</b>, using the default RTOS allocator. </p>
<p>Manage a pool of same size blocks. Fast and deterministic allocation and deallocation behaviour, suitable for use even in ISRs.</p>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Define the type of one pool block.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">  uint32_t length;</div>
<div class="line">  uint32_t width;</div>
<div class="line">  uint32_t height;</div>
<div class="line">  uint32_t weight;</div>
<div class="line">} properties_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define the pool size.</span></div>
<div class="line"><span class="keyword">constexpr</span> uint32_t pool_size = 10;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Construct the pool object instance.</span></div>
<div class="line"><a class="code hl_class" href="classos_1_1rtos_1_1memory__pool.html">memory_pool</a> mp { pool_size, <span class="keyword">sizeof</span>(properties_t) };</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">func(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Do something</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span>* buf;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get one block from pool.</span></div>
<div class="line">  buf = mp.<a class="code hl_function" href="classos_1_1rtos_1_1memory__pool.html#a398b56100a97f150fb31bcc781ced974">alloc</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ... use the buffer</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Free the buffer.</span></div>
<div class="line">  mp.free(buf);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Do something else.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassos_1_1rtos_1_1memory__pool_html"><div class="ttname"><a href="classos_1_1rtos_1_1memory__pool.html">os::rtos::memory_pool</a></div><div class="ttdoc">Synchronised memory pool, using the default RTOS allocator.</div><div class="ttdef"><b>Definition</b> <a href="os-mempool_8h_source.html#l00058">os-mempool.h:59</a></div></div>
<div class="ttc" id="aclassos_1_1rtos_1_1memory__pool_html_a398b56100a97f150fb31bcc781ced974"><div class="ttname"><a href="classos_1_1rtos_1_1memory__pool.html#a398b56100a97f150fb31bcc781ced974">os::rtos::memory_pool::alloc</a></div><div class="ttdeci">void * alloc(void)</div><div class="ttdoc">Allocate a memory block.</div><div class="ttdef"><b>Definition</b> <a href="os-mempool_8cpp_source.html#l00494">os-mempool.cpp:494</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is no equivalent of <a class="el" href="group__cmsis-plus-rtos-c-memres.html#ga5fcbe760926906d1843d4db852d9c5b8" title="Allocate an array of memory blocks (initialised to zero).">calloc()</a>; to initialise to zero a memory block, use: <div class="fragment"><div class="line">block = mp.alloc();</div>
<div class="line">memset (block, 0, mp.block_size ());</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>No POSIX similar functionality identified. Current functionality inspired by ARM CMSIS, with extensions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00058">58</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ef5fc603da1b3dfd918ca4d03f8ff97" name="a5ef5fc603da1b3dfd918ca4d03f8ff97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef5fc603da1b3dfd918ca4d03f8ff97">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">os::rtos::memory_pool::allocator_type</a> =  <a class="el" href="group__cmsis-plus-rtos-memres.html#gac00e47b1a65850b96de7c9fe0e938da1">memory::allocator</a>&lt;<a class="el" href="classos_1_1rtos_1_1thread_1_1stack.html#ab4cbbaaaf2f0a91dcc9a7cc42b7f8b98">thread::stack::allocation_element_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default RTOS allocator. </p>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00192">192</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="a2906df850164ea47bd55d45a254f6699" name="a2906df850164ea47bd55d45a254f6699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2906df850164ea47bd55d45a254f6699">&#9670;&#160;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classos_1_1rtos_1_1memory__pool.html#a2906df850164ea47bd55d45a254f6699">os::rtos::memory_pool::size_t</a> =  uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of memory pool size storage. </p>
<p>A numeric value that can hold the maximum size of the memory pool, usually a 16-bits unsigned value. </p>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00071">71</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2170a2c21e7c9c5234a111ffedecd9ce" name="a2170a2c21e7c9c5234a111ffedecd9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2170a2c21e7c9c5234a111ffedecd9ce">&#9670;&#160;</a></span>memory_pool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::memory_pool::memory_pool </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1memory__pool_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a7fd442f85898940215d53d32e7a4eee7">initializer</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a>&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a memory pool object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blocks</td><td>The maximum number of items in the pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size_bytes</td><td>The size of an item, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Reference to allocator. Default a local temporary instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise a memory pool object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the memory pool attributes shall not be affected. Upon successful initialisation, the state of the memory pool variable shall become initialised.</p>
<p>Only the memory pool itself may be used for allocations. It is not allowed to make copies of condition variable objects.</p>
<p>In cases where default memory pool attributes are appropriate, the variable <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a7fd442f85898940215d53d32e7a4eee7" title="Default memory pool initialiser.">memory_pool::initializer</a></code> can be used to initialise condition variables. The effect shall be equivalent to creating a memory pool object with the simple constructor.</p>
<p>If the attributes define a storage area (via <code>mp_pool_address</code> and <code>mp_pool_size_bytes</code>), that storage is used, otherwise the storage is dynamically allocated using the RTOS specific allocator (<code><a class="el" href="group__cmsis-plus-rtos-memres.html#gac00e47b1a65850b96de7c9fe0e938da1" title="Type of allocator used by the system objects. Must be stateless.">rtos::memory::allocator</a></code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8cpp_source.html#l00228">228</a> of file <a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a>.</p>

</div>
</div>
<a id="a60784bab43302b4e7bfc6b2964598d3e" name="a60784bab43302b4e7bfc6b2964598d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60784bab43302b4e7bfc6b2964598d3e">&#9670;&#160;</a></span>memory_pool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::memory_pool::memory_pool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1memory__pool_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a7fd442f85898940215d53d32e7a4eee7">initializer</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a5ef5fc603da1b3dfd918ca4d03f8ff97">allocator_type</a>&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a named memory pool object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocks</td><td>The maximum number of items in the pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size_bytes</td><td>The size of an item, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Reference to allocator. Default a local temporary instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise a named memory pool object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the memory pool attributes shall not be affected. Upon successful initialisation, the state of the memory pool variable shall become initialised.</p>
<p>Only the memory pool itself may be used for allocations. It is not allowed to make copies of condition variable objects.</p>
<p>In cases where default memory pool attributes are appropriate, the variable <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a7fd442f85898940215d53d32e7a4eee7" title="Default memory pool initialiser.">memory_pool::initializer</a></code> can be used to initialise condition variables. The effect shall be equivalent to creating a memory pool object with the simple constructor.</p>
<p>If the attributes define a storage area (via <code>mp_pool_address</code> and <code>mp_pool_size_bytes</code>), that storage is used, otherwise the storage is dynamically allocated using the RTOS specific allocator (<code><a class="el" href="group__cmsis-plus-rtos-memres.html#gac00e47b1a65850b96de7c9fe0e938da1" title="Type of allocator used by the system objects. Must be stateless.">rtos::memory::allocator</a></code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8cpp_source.html#l00262">262</a> of file <a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a>.</p>

</div>
</div>
<a id="ae9744239d3f89c9a63a4156e43175884" name="ae9744239d3f89c9a63a4156e43175884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9744239d3f89c9a63a4156e43175884">&#9670;&#160;</a></span>~memory_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::memory_pool::~memory_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the memory pool object instance. </p>
<p>This destructor shall destroy the memory pool object; the object becomes, in effect, uninitialised. An implementation may cause the destructor to set the object to an invalid value.</p>
<p>It shall be safe to destroy an initialised memory pool object upon which no threads are currently blocked. Attempting to destroy a memory pool object upon which other threads are currently blocked results in undefined behaviour.</p>
<p>If the storage for the memory pool was dynamically allocated, it is deallocated using the same allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8cpp_source.html#l00398">398</a> of file <a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a398b56100a97f150fb31bcc781ced974" name="a398b56100a97f150fb31bcc781ced974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398b56100a97f150fb31bcc781ced974">&#9670;&#160;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::memory_pool::alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory block, or <code>nullptr</code> if interrupted.</dd></dl>
<p>The <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a398b56100a97f150fb31bcc781ced974" title="Allocate a memory block.">alloc()</a></code> function shall allocate a fixed size memory block from the memory pool.</p>
<p>If the memory pool is empty, <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a398b56100a97f150fb31bcc781ced974" title="Allocate a memory block.">alloc()</a></code> shall block until a block is freed or until <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a398b56100a97f150fb31bcc781ced974" title="Allocate a memory block.">alloc()</a></code> is cancelled/interrupted. If more than one thread is waiting to allocate a block, when a block is freed and the Priority Scheduling option is supported, then the thread of highest priority that has been waiting the longest shall be selected to allocate the block. Otherwise, it is unspecified which waiting thread allocates the block.</p>
<p>This function uses a critical section to protect against simultaneous access from other threads or interrupts.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8cpp_source.html#l00494">494</a> of file <a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a>.</p>

</div>
</div>
<a id="a387abd2e85b6365e4f2606333502d605" name="a387abd2e85b6365e4f2606333502d605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387abd2e85b6365e4f2606333502d605">&#9670;&#160;</a></span>block_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t os::rtos::memory_pool::block_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get block size. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The block size, in bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00919">919</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="a6611d00923116927509330745999c02e" name="a6611d00923116927509330745999c02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6611d00923116927509330745999c02e">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t os::rtos::memory_pool::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get memory pool capacity. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The max number of blocks in the pool.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00908">908</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="ada288312b54cc038fcdc144ed91c53ef" name="ada288312b54cc038fcdc144ed91c53ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada288312b54cc038fcdc144ed91c53ef">&#9670;&#160;</a></span>compute_allocated_size_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t os::rtos::memory_pool::compute_allocated_size_bytes </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculator for pool storage requirements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocks</td><td>Number of blocks. </td></tr>
    <tr><td class="paramname">block_size_bytes</td><td>Size of block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total required storage in bytes, including internal alignment. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00179">179</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="a8c3f1aa4c42b7b2a94b536b8e07bb381" name="a8c3f1aa4c42b7b2a94b536b8e07bb381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3f1aa4c42b7b2a94b536b8e07bb381">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t os::rtos::memory_pool::count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get blocks count. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of blocks used from the queue.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00930">930</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="a3f1a85ba53c3d3c39ed992a1f4c7c285" name="a3f1a85ba53c3d3c39ed992a1f4c7c285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1a85ba53c3d3c39ed992a1f4c7c285">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::memory_pool::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the memory pool is empty. </p>
<dl class="section user"><dt>Parameters</dt><dd>None </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The memory pool has no allocated blocks. </td></tr>
    <tr><td class="paramname">false</td><td>The memory pool has allocated blocks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00941">941</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="a95efd50d23b62a19590750f1ff07c063" name="a95efd50d23b62a19590750f1ff07c063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95efd50d23b62a19590750f1ff07c063">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::memory_pool::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to memory block to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The memory block was released. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The block does not belong to the memory pool.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a memory block previously allocated by <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a398b56100a97f150fb31bcc781ced974" title="Allocate a memory block.">alloc()</a></code> back to the memory pool.</p>
<p>It uses a critical section to protect simultaneous access from other threads or interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8cpp_source.html#l00764">764</a> of file <a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a>.</p>

</div>
</div>
<a id="af76b6ad1dc90e2869a8c35949b551576" name="af76b6ad1dc90e2869a8c35949b551576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76b6ad1dc90e2869a8c35949b551576">&#9670;&#160;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::memory_pool::full </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the memory pool is full. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>All memory blocks are allocated. </td></tr>
    <tr><td class="paramname">false</td><td>There are still memory blocks that can be allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00952">952</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="a3103a84c5e0521c3639306f5879526ba" name="a3103a84c5e0521c3639306f5879526ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3103a84c5e0521c3639306f5879526ba">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * os::rtos::internal::object_named::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get object name. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A null terminated string.</dd></dl>
<p>All objects return a non-null string; anonymous objects return <code>"-"</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-decls_8h_source.html#l00760">760</a> of file <a class="el" href="os-decls_8h_source.html">os-decls.h</a>.</p>

</div>
</div>
<a id="aef5d78f2ac3f37daf3984758c9e2ddb2" name="aef5d78f2ac3f37daf3984758c9e2ddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d78f2ac3f37daf3984758c9e2ddb2">&#9670;&#160;</a></span>operator delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated object instance. using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p><em>ptr</em> shall be a null pointer or its value shall be a value returned by an earlier call to the (possibly replaced) <a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c" title="Allocate space for a new object instance using the RTOS system allocator.">operator new()</a> which has not been invalidated by an intervening call to operator delete(void*).</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00134">134</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="adc1c29f4a020deee857f22330e0277ed" name="adc1c29f4a020deee857f22330e0277ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1c29f4a020deee857f22330e0277ed">&#9670;&#160;</a></span>operator delete[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated array of object. instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to array of objects. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by the array form of a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00155">155</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a1456983acc3a56e02cd4a48a220f222c" name="a1456983acc3a56e02cd4a48a220f222c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1456983acc3a56e02cd4a48a220f222c">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for a new object instance using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00056">56</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a35f709b685919d096e49acb8edefe02f" name="a35f709b685919d096e49acb8edefe02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f709b685919d096e49acb8edefe02f">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace a new object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00093">93</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a27026070d8fd2c51873036cfd1661ce4" name="a27026070d8fd2c51873036cfd1661ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27026070d8fd2c51873036cfd1661ce4">&#9670;&#160;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for an array of new object instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00074">74</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="ad415429ae3487ec5ae1258b4d2a5787f" name="ad415429ae3487ec5ae1258b4d2a5787f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad415429ae3487ec5ae1258b4d2a5787f">&#9670;&#160;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace an array of new object instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00110">110</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="aef89826c91bc8b7e7b9d08644bcd0098" name="aef89826c91bc8b7e7b9d08644bcd0098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef89826c91bc8b7e7b9d08644bcd0098">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::memory_pool::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1memory__pool.html">memory_pool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare memory pools. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The given memory pool is the same as this memory pool. </td></tr>
    <tr><td class="paramname">false</td><td>The memory pools are different.</td></tr>
  </table>
  </dd>
</dl>
<p>Identical memory pools should have the same memory address. </p>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00897">897</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="aa1fde03a7e551f6d28f12a1e21d10e87" name="aa1fde03a7e551f6d28f12a1e21d10e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fde03a7e551f6d28f12a1e21d10e87">&#9670;&#160;</a></span>pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::memory_pool::pool </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pool storage address. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to storage.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00963">963</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="ac764ac06d8a23bc517ea0785caccf350" name="ac764ac06d8a23bc517ea0785caccf350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac764ac06d8a23bc517ea0785caccf350">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::memory_pool::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the memory pool. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The memory pool was reset. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines.</td></tr>
  </table>
  </dd>
</dl>
<p>Reset the memory pool to the initial state, with all blocks free.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8cpp_source.html#l00816">816</a> of file <a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a>.</p>

</div>
</div>
<a id="a368b3eeaa2c28df26b6f3970fd209f3b" name="a368b3eeaa2c28df26b6f3970fd209f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368b3eeaa2c28df26b6f3970fd209f3b">&#9670;&#160;</a></span>timed_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::memory_pool::timed_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1clock.html#a149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block with timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to wait, in clock units (ticks or seconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory block, or <code>nullptr</code> if timeout.</dd></dl>
<p>The <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a368b3eeaa2c28df26b6f3970fd209f3b" title="Allocate a memory block with timeout.">timed_alloc()</a></code> function shall allocate a fixed size memory block from the memory pool.</p>
<p>If the memory pool is empty, <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a368b3eeaa2c28df26b6f3970fd209f3b" title="Allocate a memory block with timeout.">timed_alloc()</a></code> shall block until a block is freed or until <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a368b3eeaa2c28df26b6f3970fd209f3b" title="Allocate a memory block with timeout.">timed_alloc()</a></code> is cancelled/interrupted. If more than one thread is waiting to allocate a block, when a block is freed and the Priority Scheduling option is supported, then the thread of highest priority that has been waiting the longest shall be selected to allocate the block. Otherwise, it is unspecified which waiting thread allocates the block.</p>
<p>The <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a368b3eeaa2c28df26b6f3970fd209f3b" title="Allocate a memory block with timeout.">timed_alloc()</a></code> function shall allocate any of the available blocks, regardless of their age and the order they were freed. However, if no blocks are available, the wait for such a block shall be terminated when the specified timeout expires.</p>
<p>The timeout shall expire after the number of time units (that is when the value of that clock equals or exceeds (now()+duration). The resolution of the timeout shall be the resolution of the clock on which it is based.</p>
<p>Under no circumstance shall the operation fail with a timeout if a block can be allocated from the memory pool immediately. The validity of the timeout need not be checked if the block can be allocated immediately.</p>
<p>The clock used for timeouts can be specified via the <code>clock</code> attribute. By default, the clock derived from the scheduler timer is used, and the durations are expressed in ticks.</p>
<p>This function uses a critical section to protect against simultaneous access from other threads or interrupts.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8cpp_source.html#l00656">656</a> of file <a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a>.</p>

</div>
</div>
<a id="a3755c8ce8f934469047b735209ab58b3" name="a3755c8ce8f934469047b735209ab58b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3755c8ce8f934469047b735209ab58b3">&#9670;&#160;</a></span>try_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::memory_pool::try_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to allocate a memory block. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory block, or <code>nullptr</code> if no memory available.</dd></dl>
<p>Try to allocate a fixed size memory block from the memory pool, if available, return it, otherwise return <code>nullptr</code>.</p>
<p>The <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a368b3eeaa2c28df26b6f3970fd209f3b" title="Allocate a memory block with timeout.">timed_alloc()</a></code> function shall try to allocate a fixed size memory block from the memory pool.</p>
<p>If the memory pool is empty, <code><a class="el" href="classos_1_1rtos_1_1memory__pool.html#a368b3eeaa2c28df26b6f3970fd209f3b" title="Allocate a memory block with timeout.">timed_alloc()</a></code> shall immediately return 'nullptr'.</p>
<p>This function uses a critical section to protect against simultaneous access from other threads or interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-mempool_8cpp_source.html#l00590">590</a> of file <a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7fd442f85898940215d53d32e7a4eee7" name="a7fd442f85898940215d53d32e7a4eee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd442f85898940215d53d32e7a4eee7">&#9670;&#160;</a></span>initializer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classos_1_1rtos_1_1memory__pool_1_1attributes.html">memory_pool::attributes</a> os::rtos::memory_pool::initializer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default memory pool initialiser. </p>
<p>This variable is used by the default constructor. </p>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00154">154</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<a id="a25abdce615f4418c120dfdaa66db582e" name="a25abdce615f4418c120dfdaa66db582e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25abdce615f4418c120dfdaa66db582e">&#9670;&#160;</a></span>max_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classos_1_1rtos_1_1memory__pool.html#a2906df850164ea47bd55d45a254f6699">memory_pool::size_t</a> os::rtos::memory_pool::max_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="classos_1_1rtos_1_1memory__pool.html#a2906df850164ea47bd55d45a254f6699">memory_pool::size_t</a><span class="keyword">&gt;</span> (0 - 1)</div>
<div class="ttc" id="aclassos_1_1rtos_1_1memory__pool_html_a2906df850164ea47bd55d45a254f6699"><div class="ttname"><a href="classos_1_1rtos_1_1memory__pool.html#a2906df850164ea47bd55d45a254f6699">os::rtos::memory_pool::size_t</a></div><div class="ttdeci">uint16_t size_t</div><div class="ttdoc">Type of memory pool size storage.</div><div class="ttdef"><b>Definition</b> <a href="os-mempool_8h_source.html#l00071">os-mempool.h:71</a></div></div>
</div><!-- fragment -->
<p>Maximum pool size. </p>
<p>A constant numeric value used to validate the pool size. </p>

<p class="definition">Definition at line <a class="el" href="os-mempool_8h_source.html#l00079">79</a> of file <a class="el" href="os-mempool_8h_source.html">os-mempool.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="os-mempool_8h_source.html">os-mempool.h</a></li>
<li><a class="el" href="os-mempool_8cpp_source.html">os-mempool.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceos.html">os</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos.html">rtos</a></li><li class="navelem"><a class="el" href="classos_1_1rtos_1_1memory__pool.html">memory_pool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
