<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>µOS++ IIIe Reference: os::rtos::thread_inclusive&lt; N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="common-custom.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<!-- Awesome Theme Begin -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
DoxygenAwesomeInteractiveToc.init()
DoxygenAwesomeTabs.init()
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9T84WD3CK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9T84WD3CK');
</script>
<!-- Awesome Theme End -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><a href="$relpath/../../../"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign">
   <div id="projectname">µOS++ IIIe Reference<span id="projectnumber">&#160;6.3.17</span>
   </div>
   <div id="projectbrief">The third edition of µOS++, a POSIX inspired open source framework, written in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classos_1_1rtos_1_1thread__inclusive.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classos_1_1rtos_1_1thread__inclusive-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">os::rtos::thread_inclusive&lt; N &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Template of a POSIX compliant <b>thread</b> with local stack.  
 <a href="classos_1_1rtos_1_1thread__inclusive.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="os_8h_source.html">cmsis-plus/rtos/os.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for os::rtos::thread_inclusive&lt; N &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classos_1_1rtos_1_1thread__inclusive.png" usemap="#os::rtos::thread_5Finclusive_3C_20N_20_3E_map" alt=""/>
  <map id="os::rtos::thread_5Finclusive_3C_20N_20_3E_map" name="os::rtos::thread_5Finclusive_3C_20N_20_3E_map">
<area href="classos_1_1rtos_1_1thread.html" title="POSIX compliant thread, using the default RTOS allocator." alt="os::rtos::thread" shape="rect" coords="0,112,229,136"/>
<area href="classos_1_1rtos_1_1internal_1_1object__named__system.html" title="Base class for named system objects." alt="os::rtos::internal::object_named_system" shape="rect" coords="0,56,229,80"/>
<area href="classos_1_1rtos_1_1internal_1_1object__named.html" title="Base class for named objects." alt="os::rtos::internal::object_named" shape="rect" coords="0,0,229,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aad1b11b58a161d9ee54c9ca297a28cd6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#aad1b11b58a161d9ee54c9ca297a28cd6">allocator_type</a> = <a class="el" href="group__cmsis-plus-rtos-memres.html#gac00e47b1a65850b96de7c9fe0e938da1">memory::allocator</a>&lt; stack::allocation_element_t &gt;</td></tr>
<tr class="memdesc:aad1b11b58a161d9ee54c9ca297a28cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default RTOS allocator.  <br /></td></tr>
<tr class="separator:aad1b11b58a161d9ee54c9ca297a28cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172404a80d16e472f9425ca59c30808"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#af172404a80d16e472f9425ca59c30808">func_args_t</a> = _func_args_t</td></tr>
<tr class="memdesc:af172404a80d16e472f9425ca59c30808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of thread function arguments.  <br /></td></tr>
<tr class="separator:af172404a80d16e472f9425ca59c30808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562163ef5c0911be98a342a6a2ee07bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a562163ef5c0911be98a342a6a2ee07bc">func_t</a> = void *(*)(<a class="el" href="classos_1_1rtos_1_1thread.html#af172404a80d16e472f9425ca59c30808">func_args_t</a> args)</td></tr>
<tr class="memdesc:a562163ef5c0911be98a342a6a2ee07bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of thread function.  <br /></td></tr>
<tr class="separator:a562163ef5c0911be98a342a6a2ee07bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d09b05379b4799f126477d0ac29c36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">priority_t</a> = uint8_t</td></tr>
<tr class="memdesc:aa5d09b05379b4799f126477d0ac29c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of variables holding thread priorities.  <br /></td></tr>
<tr class="separator:aa5d09b05379b4799f126477d0ac29c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad4ea288b751984ac2af3c762da7b61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a2ad4ea288b751984ac2af3c762da7b61">state_t</a> = uint8_t</td></tr>
<tr class="memdesc:a2ad4ea288b751984ac2af3c762da7b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of variables holding thread states.  <br /></td></tr>
<tr class="separator:a2ad4ea288b751984ac2af3c762da7b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructor</div></td></tr>
<tr class="memitem:a01ad81444dba0d5fac89c79293c74481"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread__inclusive.html#a01ad81444dba0d5fac89c79293c74481">thread_inclusive</a> (<a class="el" href="classos_1_1rtos_1_1thread.html#a562163ef5c0911be98a342a6a2ee07bc">func_t</a> function, <a class="el" href="classos_1_1rtos_1_1thread.html#af172404a80d16e472f9425ca59c30808">func_args_t</a> args, const <a class="el" href="classos_1_1rtos_1_1thread_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="classos_1_1rtos_1_1thread.html#a7e8750967b223d7f246629861629bb31">initializer</a>)</td></tr>
<tr class="memdesc:a01ad81444dba0d5fac89c79293c74481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a thread object instance.  <br /></td></tr>
<tr class="separator:a01ad81444dba0d5fac89c79293c74481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fea1b70c98ca55f0702d764fefa8a6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread__inclusive.html#a7fea1b70c98ca55f0702d764fefa8a6d">thread_inclusive</a> (const char *<a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a>, <a class="el" href="classos_1_1rtos_1_1thread.html#a562163ef5c0911be98a342a6a2ee07bc">func_t</a> function, <a class="el" href="classos_1_1rtos_1_1thread.html#af172404a80d16e472f9425ca59c30808">func_args_t</a> args, const <a class="el" href="classos_1_1rtos_1_1thread_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="classos_1_1rtos_1_1thread.html#a7e8750967b223d7f246629861629bb31">initializer</a>)</td></tr>
<tr class="memdesc:a7fea1b70c98ca55f0702d764fefa8a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a named thread object instance.  <br /></td></tr>
<tr class="separator:a7fea1b70c98ca55f0702d764fefa8a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ec56a7b4a7d4b74cd6ff134e67dbb3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread__inclusive.html#a11ec56a7b4a7d4b74cd6ff134e67dbb3">~thread_inclusive</a> ()</td></tr>
<tr class="memdesc:a11ec56a7b4a7d4b74cd6ff134e67dbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the thread object instance.  <br /></td></tr>
<tr class="separator:a11ec56a7b4a7d4b74cd6ff134e67dbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:affd5dcadce00449b62093777b3678571"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#affd5dcadce00449b62093777b3678571">operator==</a> (const <a class="el" href="classos_1_1rtos_1_1thread.html">thread</a> &amp;rhs) const</td></tr>
<tr class="memdesc:affd5dcadce00449b62093777b3678571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare threads.  <br /></td></tr>
<tr class="separator:affd5dcadce00449b62093777b3678571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:ace3f252d8ac48e11c6fc829903e34294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#ace3f252d8ac48e11c6fc829903e34294">cancel</a> (void)</td></tr>
<tr class="memdesc:ace3f252d8ac48e11c6fc829903e34294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel thread execution.  <br /></td></tr>
<tr class="separator:ace3f252d8ac48e11c6fc829903e34294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcfb047c0a8409b9df5f7aa94729700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#aafcfb047c0a8409b9df5f7aa94729700">detach</a> (void)</td></tr>
<tr class="memdesc:aafcfb047c0a8409b9df5f7aa94729700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a thread.  <br /></td></tr>
<tr class="separator:aafcfb047c0a8409b9df5f7aa94729700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d3bab3f4bfc33474e7fdb9dfda172e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a87d3bab3f4bfc33474e7fdb9dfda172e">join</a> (void **exit_ptr=nullptr)</td></tr>
<tr class="memdesc:a87d3bab3f4bfc33474e7fdb9dfda172e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for thread termination.  <br /></td></tr>
<tr class="separator:a87d3bab3f4bfc33474e7fdb9dfda172e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d49a9e876e1977a6e46ad43856c36c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a2d49a9e876e1977a6e46ad43856c36c5">priority</a> (<a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">priority_t</a> prio)</td></tr>
<tr class="memdesc:a2d49a9e876e1977a6e46ad43856c36c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the assigned scheduling priority.  <br /></td></tr>
<tr class="separator:a2d49a9e876e1977a6e46ad43856c36c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18df423d072eae8184f0fc6395c7262"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#aa18df423d072eae8184f0fc6395c7262">priority</a> (void)</td></tr>
<tr class="memdesc:aa18df423d072eae8184f0fc6395c7262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current scheduling priority.  <br /></td></tr>
<tr class="separator:aa18df423d072eae8184f0fc6395c7262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58bbc0dfd3d9a7a38ba17a3039c527d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#ac58bbc0dfd3d9a7a38ba17a3039c527d">priority_inherited</a> (<a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">priority_t</a> prio)</td></tr>
<tr class="memdesc:ac58bbc0dfd3d9a7a38ba17a3039c527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the inherited scheduling priority.  <br /></td></tr>
<tr class="separator:ac58bbc0dfd3d9a7a38ba17a3039c527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2c8272ff9aca36227e77f0f11df318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a8e2c8272ff9aca36227e77f0f11df318">priority_inherited</a> (void)</td></tr>
<tr class="memdesc:a8e2c8272ff9aca36227e77f0f11df318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inherited scheduling priority.  <br /></td></tr>
<tr class="separator:a8e2c8272ff9aca36227e77f0f11df318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab95e23a51dac01b8a8aae6bb3bfd4f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#aab95e23a51dac01b8a8aae6bb3bfd4f6">interrupted</a> (void)</td></tr>
<tr class="memdesc:aab95e23a51dac01b8a8aae6bb3bfd4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if interrupted.  <br /></td></tr>
<tr class="separator:aab95e23a51dac01b8a8aae6bb3bfd4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec99e3a711e80b3cbaa18b1c520f966f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#aec99e3a711e80b3cbaa18b1c520f966f">interrupt</a> (bool interrupt=true)</td></tr>
<tr class="memdesc:aec99e3a711e80b3cbaa18b1c520f966f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the interrupt flag, possibly interrupting the thread.  <br /></td></tr>
<tr class="separator:aec99e3a711e80b3cbaa18b1c520f966f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacc988dec93ede0c0fd178271684659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classos_1_1rtos_1_1thread.html#a2ad4ea288b751984ac2af3c762da7b61">state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#afacc988dec93ede0c0fd178271684659">state</a> (void) const</td></tr>
<tr class="memdesc:afacc988dec93ede0c0fd178271684659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get thread scheduler state.  <br /></td></tr>
<tr class="separator:afacc988dec93ede0c0fd178271684659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efeb8a95a46317538141cdad11f73a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a68efeb8a95a46317538141cdad11f73a">resume</a> (void)</td></tr>
<tr class="memdesc:a68efeb8a95a46317538141cdad11f73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the thread.  <br /></td></tr>
<tr class="separator:a68efeb8a95a46317538141cdad11f73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3df5f832debb70d2dd4d667eea5627"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a2a3df5f832debb70d2dd4d667eea5627">function_args</a> (void) const</td></tr>
<tr class="memdesc:a2a3df5f832debb70d2dd4d667eea5627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread function arguments.  <br /></td></tr>
<tr class="separator:a2a3df5f832debb70d2dd4d667eea5627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dd633153f7210c52d1c6210e660047"><td class="memItemLeft" align="right" valign="top">os_thread_user_storage_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a62dd633153f7210c52d1c6210e660047">user_storage</a> (void)</td></tr>
<tr class="memdesc:a62dd633153f7210c52d1c6210e660047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the user storage.  <br /></td></tr>
<tr class="separator:a62dd633153f7210c52d1c6210e660047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9403145c7f69493bb268a4a47ffbf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a0d9403145c7f69493bb268a4a47ffbf7">flags_raise</a> (<a class="el" href="namespaceos_1_1rtos_1_1flags.html#a87571a2d62e491d2af4e4390eb1aca06">flags::mask_t</a> mask, <a class="el" href="namespaceos_1_1rtos_1_1flags.html#a87571a2d62e491d2af4e4390eb1aca06">flags::mask_t</a> *oflags=nullptr)</td></tr>
<tr class="memdesc:a0d9403145c7f69493bb268a4a47ffbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise thread event flags.  <br /></td></tr>
<tr class="separator:a0d9403145c7f69493bb268a4a47ffbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104646528da7762508267f8a8151fc51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a104646528da7762508267f8a8151fc51">kill</a> (void)</td></tr>
<tr class="memdesc:a104646528da7762508267f8a8151fc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force thread termination.  <br /></td></tr>
<tr class="separator:a104646528da7762508267f8a8151fc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d41467e9e43c68581743e5d6ce5405"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classos_1_1rtos_1_1thread_1_1stack.html">thread::stack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a84d41467e9e43c68581743e5d6ce5405">stack</a> (void)</td></tr>
<tr class="memdesc:a84d41467e9e43c68581743e5d6ce5405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread context stack.  <br /></td></tr>
<tr class="separator:a84d41467e9e43c68581743e5d6ce5405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1532618bb85495bd290d23827ddd1f3"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classos_1_1rtos_1_1thread_1_1statistics.html">thread::statistics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#aa1532618bb85495bd290d23827ddd1f3">statistics</a> (void)</td></tr>
<tr class="separator:aa1532618bb85495bd290d23827ddd1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a3103a84c5e0521c3639306f5879526ba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a> (void) const</td></tr>
<tr class="memdesc:a3103a84c5e0521c3639306f5879526ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get object name.  <br /></td></tr>
<tr class="separator:a3103a84c5e0521c3639306f5879526ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a1456983acc3a56e02cd4a48a220f222c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c">operator new</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a1456983acc3a56e02cd4a48a220f222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a new object instance using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:a1456983acc3a56e02cd4a48a220f222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f709b685919d096e49acb8edefe02f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a35f709b685919d096e49acb8edefe02f">operator new</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:a35f709b685919d096e49acb8edefe02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new object instance.  <br /></td></tr>
<tr class="separator:a35f709b685919d096e49acb8edefe02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27026070d8fd2c51873036cfd1661ce4"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a27026070d8fd2c51873036cfd1661ce4">operator new[]</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a27026070d8fd2c51873036cfd1661ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for an array of new object instances using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:a27026070d8fd2c51873036cfd1661ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#ad415429ae3487ec5ae1258b4d2a5787f">operator new[]</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:ad415429ae3487ec5ae1258b4d2a5787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace an array of new object instances.  <br /></td></tr>
<tr class="separator:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#aef5d78f2ac3f37daf3984758c9e2ddb2">operator delete</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated object instance. using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c29f4a020deee857f22330e0277ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#adc1c29f4a020deee857f22330e0277ed">operator delete[]</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:adc1c29f4a020deee857f22330e0277ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated array of object. instances using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:adc1c29f4a020deee857f22330e0277ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a649c72d336c3b64853965f5f96c28755"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a649c72d336c3b64853965f5f96c28755">errno_</a> = 0</td></tr>
<tr class="separator:a649c72d336c3b64853965f5f96c28755"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7e8750967b223d7f246629861629bb31"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classos_1_1rtos_1_1thread_1_1attributes.html">attributes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread.html#a7e8750967b223d7f246629861629bb31">initializer</a></td></tr>
<tr class="memdesc:a7e8750967b223d7f246629861629bb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default thread initialiser.  <br /></td></tr>
<tr class="separator:a7e8750967b223d7f246629861629bb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab873c55d379e8286c6481e9bca5393"><td class="memItemLeft" align="right" valign="top">static const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1thread__inclusive.html#a5ab873c55d379e8286c6481e9bca5393">stack_size_bytes</a> = N</td></tr>
<tr class="memdesc:a5ab873c55d379e8286c6481e9bca5393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local constant based on template definition.  <br /></td></tr>
<tr class="separator:a5ab873c55d379e8286c6481e9bca5393"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::size_t N = port::stack::default_size_bytes&gt;<br />
class os::rtos::thread_inclusive&lt; N &gt;</div><p>Template of a POSIX compliant <b>thread</b> with local stack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Size of statically allocated stack in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l01772">1772</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aad1b11b58a161d9ee54c9ca297a28cd6" name="aad1b11b58a161d9ee54c9ca297a28cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1b11b58a161d9ee54c9ca297a28cd6">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classos_1_1rtos_1_1thread.html#aad1b11b58a161d9ee54c9ca297a28cd6">os::rtos::thread::allocator_type</a> =  <a class="el" href="group__cmsis-plus-rtos-memres.html#gac00e47b1a65850b96de7c9fe0e938da1">memory::allocator</a>&lt;stack::allocation_element_t&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default RTOS allocator. </p>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l00975">975</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="af172404a80d16e472f9425ca59c30808" name="af172404a80d16e472f9425ca59c30808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af172404a80d16e472f9425ca59c30808">&#9670;&#160;</a></span>func_args_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classos_1_1rtos_1_1thread.html#af172404a80d16e472f9425ca59c30808">os::rtos::thread::func_args_t</a> =  _func_args_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of thread function arguments. </p>
<p>Useful to cast other similar types to silence possible compiler warnings. </p>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l00389">389</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a562163ef5c0911be98a342a6a2ee07bc" name="a562163ef5c0911be98a342a6a2ee07bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562163ef5c0911be98a342a6a2ee07bc">&#9670;&#160;</a></span>func_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classos_1_1rtos_1_1thread.html#a562163ef5c0911be98a342a6a2ee07bc">os::rtos::thread::func_t</a> =  void* (*) (<a class="el" href="classos_1_1rtos_1_1thread.html#af172404a80d16e472f9425ca59c30808">func_args_t</a> args)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of thread function. </p>
<p>Useful to cast other similar types to silence possible compiler warnings. </p>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l00397">397</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="aa5d09b05379b4799f126477d0ac29c36" name="aa5d09b05379b4799f126477d0ac29c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d09b05379b4799f126477d0ac29c36">&#9670;&#160;</a></span>priority_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">os::rtos::thread::priority_t</a> =  uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of variables holding thread priorities. </p>
<p>A numeric type used to hold thread priorities, affecting the thread behaviour, like scheduling and thread wakeup due to events; usually an unsigned 8-bits type.</p>
<p>Higher values represent higher priorities. </p>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l00252">252</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a2ad4ea288b751984ac2af3c762da7b61" name="a2ad4ea288b751984ac2af3c762da7b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad4ea288b751984ac2af3c762da7b61">&#9670;&#160;</a></span>state_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classos_1_1rtos_1_1thread.html#a2ad4ea288b751984ac2af3c762da7b61">os::rtos::thread::state_t</a> =  uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of variables holding thread states. </p>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l00337">337</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01ad81444dba0d5fac89c79293c74481" name="a01ad81444dba0d5fac89c79293c74481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ad81444dba0d5fac89c79293c74481">&#9670;&#160;</a></span>thread_inclusive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1thread__inclusive.html">os::rtos::thread_inclusive</a>&lt; N &gt;::thread_inclusive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1thread.html#a562163ef5c0911be98a342a6a2ee07bc">func_t</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1thread.html#af172404a80d16e472f9425ca59c30808">func_args_t</a>&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1thread_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classos_1_1rtos_1_1thread.html#a7e8750967b223d7f246629861629bb31">initializer</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a thread object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Pointer to thread function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Pointer to thread function arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise a thread object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the thread attributes shall not be affected. Upon successful initialisation, the state of the thread object shall become initialised, and the thread is added to the ready list.</p>
<p>Only the thread object itself may be used for running the function. It is not allowed to make copies of thread objects.</p>
<p>In cases where default thread attributes are appropriate, the variable <code><a class="el" href="classos_1_1rtos_1_1thread.html#a7e8750967b223d7f246629861629bb31" title="Default thread initialiser.">thread::initializer</a></code> can be used to initialise threads. The effect shall be equivalent to creating a thread object with the default constructor.</p>
<p>The thread is created to execute <em>function</em> with <em>args</em> as its sole argument. If the function returns, the effect shall be as if there was an implicit call to <code><a class="el" href="exit_8c.html#a7b17e5913b7dff48eec9ba3976ccfd3c">exit()</a></code> using the return value of function as the exit code. Note that the thread in which <code><a class="el" href="os-main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="Default implementation of main().">main()</a></code> was originally invoked differs from this. When it returns from <code><a class="el" href="os-main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="Default implementation of main().">main()</a></code>, the effect shall be as if there was an implicit call to <code><a class="el" href="exit_8c.html#a7b17e5913b7dff48eec9ba3976ccfd3c">exit()</a></code> using the return value of <code><a class="el" href="os-main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="Default implementation of main().">main()</a></code> as the exit code.</p>
<p>The storage shall be statically allocated inside the thread object instance.</p>
<dl class="section note"><dt>Note</dt><dd>These objects are better instantiated as global static objects. When instantiated on the thread stack, the stack should be sized accordingly.</dd></dl>
<p>Implemented as a wrapper over the parent constructor, automatically passing the stack size and address.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html"><code>pthread_create()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02675">2675</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a7fea1b70c98ca55f0702d764fefa8a6d" name="a7fea1b70c98ca55f0702d764fefa8a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fea1b70c98ca55f0702d764fefa8a6d">&#9670;&#160;</a></span>thread_inclusive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1thread__inclusive.html">os::rtos::thread_inclusive</a>&lt; N &gt;::thread_inclusive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1thread.html#a562163ef5c0911be98a342a6a2ee07bc">func_t</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1thread.html#af172404a80d16e472f9425ca59c30808">func_args_t</a>&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1thread_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="classos_1_1rtos_1_1thread.html#a7e8750967b223d7f246629861629bb31">initializer</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a named thread object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Pointer to thread function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Pointer to thread function arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor shall initialise a named thread object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the thread attributes shall not be affected. Upon successful initialisation, the state of the thread object shall become initialised, and the thread is added to the ready list.</p>
<p>Only the thread object itself may be used for running the function. It is not allowed to make copies of thread objects.</p>
<p>In cases where default thread attributes are appropriate, the variable <code><a class="el" href="classos_1_1rtos_1_1thread.html#a7e8750967b223d7f246629861629bb31" title="Default thread initialiser.">thread::initializer</a></code> can be used to initialise threads. The effect shall be equivalent to creating a thread object with the default constructor.</p>
<p>The thread is created to execute <em>function</em> with <em>args</em> as its sole argument. If the function returns, the effect shall be as if there was an implicit call to <code><a class="el" href="exit_8c.html#a7b17e5913b7dff48eec9ba3976ccfd3c">exit()</a></code> using the return value of function as the exit code. Note that the thread in which <code><a class="el" href="os-main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="Default implementation of main().">main()</a></code> was originally invoked differs from this. When it returns from <code><a class="el" href="os-main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="Default implementation of main().">main()</a></code>, the effect shall be as if there was an implicit call to <code><a class="el" href="exit_8c.html#a7b17e5913b7dff48eec9ba3976ccfd3c">exit()</a></code> using the return value of <code><a class="el" href="os-main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title="Default implementation of main().">main()</a></code> as the exit code.</p>
<p>The storage shall be statically allocated inside the thread object instance.</p>
<dl class="section note"><dt>Note</dt><dd>These objects are better instantiated as global static objects. When instantiated on the thread stack, the stack should be sized accordingly.</dd></dl>
<p>Implemented as a wrapper over the parent constructor, automatically passing the stack size and address.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html"><code>pthread_create()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02730">2730</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a11ec56a7b4a7d4b74cd6ff134e67dbb3" name="a11ec56a7b4a7d4b74cd6ff134e67dbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ec56a7b4a7d4b74cd6ff134e67dbb3">&#9670;&#160;</a></span>~thread_inclusive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1thread__inclusive.html">os::rtos::thread_inclusive</a>&lt; N &gt;::~<a class="el" href="classos_1_1rtos_1_1thread__inclusive.html">thread_inclusive</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the thread object instance. </p>
<p>This destructor shall destroy the thread object; the object becomes, in effect, uninitialised. An implementation may cause the destructor to set the object to an invalid value.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>No POSIX similar functionality identified.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02754">2754</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace3f252d8ac48e11c6fc829903e34294" name="ace3f252d8ac48e11c6fc829903e34294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3f252d8ac48e11c6fc829903e34294">&#9670;&#160;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> thread::cancel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel thread execution. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The cancel request was sent to the thread. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code><a class="el" href="classos_1_1rtos_1_1thread.html#ace3f252d8ac48e11c6fc829903e34294" title="Cancel thread execution.">cancel()</a></code> function shall not return an error code of <code>EINTR</code>. If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail and report an <code>ESRCH</code> error. error number is returned.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Implement it properly (thread interruption is not yet fully implemented).</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cancel.html"><code>pthread_cancel()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00911">911</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="aafcfb047c0a8409b9df5f7aa94729700" name="aafcfb047c0a8409b9df5f7aa94729700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcfb047c0a8409b9df5f7aa94729700">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> thread::detach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detach a thread. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The thread was detached. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines.</td></tr>
  </table>
  </dd>
</dl>
<p>Indicate to the implementation that storage for the thread thread can be reclaimed when that thread terminates. If thread has not terminated, <code><a class="el" href="classos_1_1rtos_1_1thread.html#aafcfb047c0a8409b9df5f7aa94729700" title="Detach a thread.">detach()</a></code> shall not cause it to terminate. The behaviour is undefined if the value specified by the thread argument to <code><a class="el" href="classos_1_1rtos_1_1thread.html#aafcfb047c0a8409b9df5f7aa94729700" title="Detach a thread.">detach()</a></code> does not refer to a joinable thread.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_detach.html"><code>pthread_detach()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<p>The <code><a class="el" href="classos_1_1rtos_1_1thread.html#aafcfb047c0a8409b9df5f7aa94729700" title="Detach a thread.">detach()</a></code> function shall not return an error code of <code>EINTR</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00804">804</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="a0d9403145c7f69493bb268a4a47ffbf7" name="a0d9403145c7f69493bb268a4a47ffbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9403145c7f69493bb268a4a47ffbf7">&#9670;&#160;</a></span>flags_raise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> thread::flags_raise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceos_1_1rtos_1_1flags.html#a87571a2d62e491d2af4e4390eb1aca06">flags::mask_t</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceos_1_1rtos_1_1flags.html#a87571a2d62e491d2af4e4390eb1aca06">flags::mask_t</a> *&#160;</td>
          <td class="paramname"><em>oflags</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raise thread event flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>The OR-ed flags to raise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oflags</td><td>Optional pointer where to store the previous flags; may be <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The flags were raised. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The mask is zero. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines.</td></tr>
  </table>
  </dd>
</dl>
<p>Set more bits in the thread current event flags mask. Use OR at bit-mask level. Wake-up the thread to evaluate the event flags.</p>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l01206">1206</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="a2a3df5f832debb70d2dd4d667eea5627" name="a2a3df5f832debb70d2dd4d667eea5627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3df5f832debb70d2dd4d667eea5627">&#9670;&#160;</a></span>function_args()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * thread::function_args </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the thread function arguments. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to arguments.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02315">2315</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="aec99e3a711e80b3cbaa18b1c520f966f" name="aec99e3a711e80b3cbaa18b1c520f966f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec99e3a711e80b3cbaa18b1c520f966f">&#9670;&#160;</a></span>interrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool thread::interrupt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the interrupt flag, possibly interrupting the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupt</td><td>Flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value of the interrupt flag.</dd></dl>
<p>If the interrupt flag is true, threads waiting for an event are notified immediately (actually as soon as the thread priority allows it to run).</p>
<p>After the thread detects the interrupted condition, it must clear the interrupted flag.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00936">936</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="aab95e23a51dac01b8a8aae6bb3bfd4f6" name="aab95e23a51dac01b8a8aae6bb3bfd4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab95e23a51dac01b8a8aae6bb3bfd4f6">&#9670;&#160;</a></span>interrupted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool thread::interrupted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if interrupted. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The thread was interrupted. </td></tr>
    <tr><td class="paramname">false</td><td>The thread was not interrupted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02326">2326</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a87d3bab3f4bfc33474e7fdb9dfda172e" name="a87d3bab3f4bfc33474e7fdb9dfda172e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d3bab3f4bfc33474e7fdb9dfda172e">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> thread::join </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>exit_ptr</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for thread termination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_ptr</td><td>Pointer to thread exit value. (Optional, may be nullptr). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The thread was terminated. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines.</td></tr>
  </table>
  </dd>
</dl>
<p>Suspend execution of the calling thread until the target thread terminates, unless the target thread has already terminated. On return from a successful <code><a class="el" href="classos_1_1rtos_1_1thread.html#a87d3bab3f4bfc33474e7fdb9dfda172e" title="Wait for thread termination.">join()</a></code> call with a non-NULL <em>exit_ptr</em> argument, the value passed to <code><a class="el" href="exit_8c.html#a7b17e5913b7dff48eec9ba3976ccfd3c">exit()</a></code> by the terminating thread shall be made available in the location referenced by <em>exit_ptr</em>. When a <code><a class="el" href="classos_1_1rtos_1_1thread.html#a87d3bab3f4bfc33474e7fdb9dfda172e" title="Wait for thread termination.">join()</a></code> returns successfully, the target thread has been terminated. The results of multiple simultaneous calls to <code><a class="el" href="classos_1_1rtos_1_1thread.html#a87d3bab3f4bfc33474e7fdb9dfda172e" title="Wait for thread termination.">join()</a></code> specifying the same target thread are undefined. If the thread calling <code><a class="el" href="classos_1_1rtos_1_1thread.html#a87d3bab3f4bfc33474e7fdb9dfda172e" title="Wait for thread termination.">join()</a></code> is cancelled, then the target thread shall not be detached.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html"><code>pthread_join()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<p>The <a class="el" href="classos_1_1rtos_1_1thread.html#a87d3bab3f4bfc33474e7fdb9dfda172e" title="Wait for thread termination.">join()</a> function may fail if: [EDEADLK] A deadlock was detected.</p>
<p>The <code><a class="el" href="classos_1_1rtos_1_1thread.html#a87d3bab3f4bfc33474e7fdb9dfda172e" title="Wait for thread termination.">join()</a></code> function shall not return an error code of [EINTR].</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00859">859</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="a104646528da7762508267f8a8151fc51" name="a104646528da7762508267f8a8151fc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104646528da7762508267f8a8151fc51">&#9670;&#160;</a></span>kill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> thread::kill </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force thread termination. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The tread was terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_kill.html"><code>pthread_kill()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l01127">1127</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="a3103a84c5e0521c3639306f5879526ba" name="a3103a84c5e0521c3639306f5879526ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3103a84c5e0521c3639306f5879526ba">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * os::rtos::internal::object_named::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get object name. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A null terminated string.</dd></dl>
<p>All objects return a non-null string; anonymous objects return <code>"-"</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-decls_8h_source.html#l00760">760</a> of file <a class="el" href="os-decls_8h_source.html">os-decls.h</a>.</p>

</div>
</div>
<a id="aef5d78f2ac3f37daf3984758c9e2ddb2" name="aef5d78f2ac3f37daf3984758c9e2ddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d78f2ac3f37daf3984758c9e2ddb2">&#9670;&#160;</a></span>operator delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated object instance. using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p><em>ptr</em> shall be a null pointer or its value shall be a value returned by an earlier call to the (possibly replaced) <a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c" title="Allocate space for a new object instance using the RTOS system allocator.">operator new()</a> which has not been invalidated by an intervening call to operator delete(void*).</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00134">134</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="adc1c29f4a020deee857f22330e0277ed" name="adc1c29f4a020deee857f22330e0277ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1c29f4a020deee857f22330e0277ed">&#9670;&#160;</a></span>operator delete[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated array of object. instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to array of objects. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by the array form of a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00155">155</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a1456983acc3a56e02cd4a48a220f222c" name="a1456983acc3a56e02cd4a48a220f222c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1456983acc3a56e02cd4a48a220f222c">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for a new object instance using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00056">56</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a35f709b685919d096e49acb8edefe02f" name="a35f709b685919d096e49acb8edefe02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f709b685919d096e49acb8edefe02f">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace a new object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00093">93</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a27026070d8fd2c51873036cfd1661ce4" name="a27026070d8fd2c51873036cfd1661ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27026070d8fd2c51873036cfd1661ce4">&#9670;&#160;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for an array of new object instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00074">74</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="ad415429ae3487ec5ae1258b4d2a5787f" name="ad415429ae3487ec5ae1258b4d2a5787f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad415429ae3487ec5ae1258b4d2a5787f">&#9670;&#160;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace an array of new object instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00110">110</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="affd5dcadce00449b62093777b3678571" name="affd5dcadce00449b62093777b3678571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd5dcadce00449b62093777b3678571">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool thread::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1thread.html">thread</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare threads. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The given thread is the same as this thread. </td></tr>
    <tr><td class="paramname">false</td><td>The threads are different.</td></tr>
  </table>
  </dd>
</dl>
<p>Identical threads should have the same memory address.</p>
<p>Compatible with POSIX pthread_equal(). <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_equal.html">http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_equal.html</a> </p>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02293">2293</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a2d49a9e876e1977a6e46ad43856c36c5" name="a2d49a9e876e1977a6e46ad43856c36c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d49a9e876e1977a6e46ad43856c36c5">&#9670;&#160;</a></span>priority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> <a class="el" href="structos_1_1rtos_1_1thread_1_1priority.html">thread::priority</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">priority_t</a>&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the assigned scheduling priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>New priority. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The priority was set. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The value of prio is invalid for the scheduling policy of the specified thread.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the scheduling priority for the thread to the value given by <em>prio</em>.</p>
<p>If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail and report an <code>ESRCH</code> error.</p>
<p>The <code>priority()</code> function shall not return an error code of <code>EINTR</code>.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setschedprio.html"><code>pthread_setschedprio()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00658">658</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="aa18df423d072eae8184f0fc6395c7262" name="aa18df423d072eae8184f0fc6395c7262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18df423d072eae8184f0fc6395c7262">&#9670;&#160;</a></span>priority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">thread::priority_t</a> <a class="el" href="structos_1_1rtos_1_1thread_1_1priority.html">thread::priority</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current scheduling priority. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The thread priority.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00602">602</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="ac58bbc0dfd3d9a7a38ba17a3039c527d" name="ac58bbc0dfd3d9a7a38ba17a3039c527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58bbc0dfd3d9a7a38ba17a3039c527d">&#9670;&#160;</a></span>priority_inherited() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> thread::priority_inherited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">priority_t</a>&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the inherited scheduling priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>New priority. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The priority was set. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>The value of prio is invalid for the scheduling policy of the specified thread.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the scheduling inherited priority for the thread to the value given by <em>prio</em>.</p>
<p>If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail and report an <code>ESRCH</code> error.</p>
<p>The <code><a class="el" href="classos_1_1rtos_1_1thread.html#a8e2c8272ff9aca36227e77f0f11df318" title="Get the inherited scheduling priority.">priority_inherited()</a></code> function shall not return an error code of <code>EINTR</code>.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00726">726</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="a8e2c8272ff9aca36227e77f0f11df318" name="a8e2c8272ff9aca36227e77f0f11df318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2c8272ff9aca36227e77f0f11df318">&#9670;&#160;</a></span>priority_inherited() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1thread.html#aa5d09b05379b4799f126477d0ac29c36">thread::priority_t</a> thread::priority_inherited </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inherited scheduling priority. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The thread inherited priority. May be <code>priority::none</code>.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00630">630</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="a68efeb8a95a46317538141cdad11f73a" name="a68efeb8a95a46317538141cdad11f73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efeb8a95a46317538141cdad11f73a">&#9670;&#160;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread::resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume the thread. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Internal, used in the implementation of synchronisation objects.</p>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Extension to standard, no POSIX similar functionality identified.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8cpp_source.html#l00551">551</a> of file <a class="el" href="os-thread_8cpp_source.html">os-thread.cpp</a>.</p>

</div>
</div>
<a id="a84d41467e9e43c68581743e5d6ce5405" name="a84d41467e9e43c68581743e5d6ce5405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d41467e9e43c68581743e5d6ce5405">&#9670;&#160;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classos_1_1rtos_1_1thread_1_1stack.html">thread::stack</a> &amp; <a class="el" href="classos_1_1rtos_1_1thread_1_1stack.html">thread::stack</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the thread context stack. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the context stack object instance.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02396">2396</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="afacc988dec93ede0c0fd178271684659" name="afacc988dec93ede0c0fd178271684659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacc988dec93ede0c0fd178271684659">&#9670;&#160;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classos_1_1rtos_1_1thread.html#a2ad4ea288b751984ac2af3c762da7b61">thread::state_t</a> <a class="el" href="structos_1_1rtos_1_1thread_1_1state.html">thread::state</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get thread scheduler state. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Thread scheduler state.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02304">2304</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="aa1532618bb85495bd290d23827ddd1f3" name="aa1532618bb85495bd290d23827ddd1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1532618bb85495bd290d23827ddd1f3">&#9670;&#160;</a></span>statistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classos_1_1rtos_1_1thread_1_1statistics.html">thread::statistics</a> &amp; <a class="el" href="classos_1_1rtos_1_1thread_1_1statistics.html">thread::statistics</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02409">2409</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a62dd633153f7210c52d1c6210e660047" name="a62dd633153f7210c52d1c6210e660047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62dd633153f7210c52d1c6210e660047">&#9670;&#160;</a></span>user_storage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">os_thread_user_storage_t * thread::user_storage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the user storage. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the thread user storage.</dd></dl>
<p>The user storage is a custom structure defined in <code>&lt;<a class="el" href="os-app-config_8h.html" title="Application configuration file.">os-app-config.h</a>&gt;</code>, which is added to each and every thread storage. Applications can store here any data.</p>
<p>Inspired by (actually a generalisation of) µC-OS III task user registers and FreeRTOS thread local storage, which proved useful when implementing CMSIS+ over FreeRTOS.</p>
<dl class="section note"><dt>Note</dt><dd>Available only when <code>OS_INCLUDE_RTOS_CUSTOM_THREAD_USER_STORAGE</code> is defined.</dd>
<dd>
Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l02351">2351</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a649c72d336c3b64853965f5f96c28755" name="a649c72d336c3b64853965f5f96c28755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649c72d336c3b64853965f5f96c28755">&#9670;&#160;</a></span>errno_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int os::rtos::thread::errno_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l00236">236</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a7e8750967b223d7f246629861629bb31" name="a7e8750967b223d7f246629861629bb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8750967b223d7f246629861629bb31">&#9670;&#160;</a></span>initializer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classos_1_1rtos_1_1thread_1_1attributes.html">thread::attributes</a> thread::initializer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default thread initialiser. </p>
<p>This variable is used by the default constructor. </p>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l00968">968</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<a id="a5ab873c55d379e8286c6481e9bca5393" name="a5ab873c55d379e8286c6481e9bca5393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab873c55d379e8286c6481e9bca5393">&#9670;&#160;</a></span>stack_size_bytes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N = port::stack::default_size_bytes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::size_t <a class="el" href="classos_1_1rtos_1_1thread__inclusive.html">os::rtos::thread_inclusive</a>&lt; N &gt;::stack_size_bytes = N</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Local constant based on template definition. </p>

<p class="definition">Definition at line <a class="el" href="os-thread_8h_source.html#l01779">1779</a> of file <a class="el" href="os-thread_8h_source.html">os-thread.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="os-thread_8h_source.html">os-thread.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceos.html">os</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos.html">rtos</a></li><li class="navelem"><a class="el" href="classos_1_1rtos_1_1thread__inclusive.html">thread_inclusive</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
