<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>µOS++ IIIe Reference: os::rtos::condition_variable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="common-custom.css" rel="stylesheet" type="text/css"/>
<link href="cards.css" rel="stylesheet" type="text/css"/>
<!-- Awesome Theme Begin -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
DoxygenAwesomeInteractiveToc.init()
DoxygenAwesomeTabs.init()
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9T84WD3CK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9T84WD3CK');
</script>
<!-- Awesome Theme End -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><a href="$relpath/../../../"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign">
   <div id="projectname">µOS++ IIIe Reference<span id="projectnumber">&#160;6.3.17</span>
   </div>
   <div id="projectbrief">The third edition of µOS++, a POSIX inspired open source framework, written in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classos_1_1rtos_1_1condition__variable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classos_1_1rtos_1_1condition__variable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">os::rtos::condition_variable Class Reference<div class="ingroups"><a class="el" href="group__cmsis-plus-rtos.html">µOS++ RTOS C++ API</a> &raquo; <a class="el" href="group__cmsis-plus-rtos-condvar.html">Condition variables</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>POSIX compliant <b>condition variable</b>.  
 <a href="classos_1_1rtos_1_1condition__variable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="os_8h_source.html">cmsis-plus/rtos/os.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for os::rtos::condition_variable:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classos_1_1rtos_1_1condition__variable.png" usemap="#os::rtos::condition_5Fvariable_map" alt=""/>
  <map id="os::rtos::condition_5Fvariable_map" name="os::rtos::condition_5Fvariable_map">
<area href="classos_1_1rtos_1_1internal_1_1object__named__system.html" title="Base class for named system objects." alt="os::rtos::internal::object_named_system" shape="rect" coords="0,56,229,80"/>
<area href="classos_1_1rtos_1_1internal_1_1object__named.html" title="Base class for named objects." alt="os::rtos::internal::object_named" shape="rect" coords="0,0,229,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable_1_1attributes.html">attributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable attributes.  <a href="classos_1_1rtos_1_1condition__variable_1_1attributes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructor</div></td></tr>
<tr class="memitem:ad61db5c36f5744c8d020dac53a55cd65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable.html#ad61db5c36f5744c8d020dac53a55cd65">condition_variable</a> (const <a class="el" href="classos_1_1rtos_1_1condition__variable_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="group__cmsis-plus-rtos-condvar.html#ga33e431621c631497db5d26dc4736d51d">initializer</a>)</td></tr>
<tr class="memdesc:ad61db5c36f5744c8d020dac53a55cd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a condition variable object instance.  <br /></td></tr>
<tr class="separator:ad61db5c36f5744c8d020dac53a55cd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af745a5ce4a56cfad74cc67d4aab9a688"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable.html#af745a5ce4a56cfad74cc67d4aab9a688">condition_variable</a> (const char *<a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a>, const <a class="el" href="classos_1_1rtos_1_1condition__variable_1_1attributes.html">attributes</a> &amp;attr=<a class="el" href="group__cmsis-plus-rtos-condvar.html#ga33e431621c631497db5d26dc4736d51d">initializer</a>)</td></tr>
<tr class="memdesc:af745a5ce4a56cfad74cc67d4aab9a688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a named condition variable object instance.  <br /></td></tr>
<tr class="separator:af745a5ce4a56cfad74cc67d4aab9a688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa0dad7f07e3fbc6f2ff8bd865bd0df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable.html#adaa0dad7f07e3fbc6f2ff8bd865bd0df">~condition_variable</a> ()</td></tr>
<tr class="memdesc:adaa0dad7f07e3fbc6f2ff8bd865bd0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the condition variable object instance.  <br /></td></tr>
<tr class="separator:adaa0dad7f07e3fbc6f2ff8bd865bd0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:ad63aece1e3bb6cf91a89f3923361d503"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable.html#ad63aece1e3bb6cf91a89f3923361d503">operator==</a> (const <a class="el" href="classos_1_1rtos_1_1condition__variable.html">condition_variable</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ad63aece1e3bb6cf91a89f3923361d503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare condition variables.  <br /></td></tr>
<tr class="separator:ad63aece1e3bb6cf91a89f3923361d503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a2cee82ef11f1690e478733a1d7abe766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable.html#a2cee82ef11f1690e478733a1d7abe766">signal</a> (void)</td></tr>
<tr class="memdesc:a2cee82ef11f1690e478733a1d7abe766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify one thread waiting for a condition variable.  <br /></td></tr>
<tr class="separator:a2cee82ef11f1690e478733a1d7abe766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e53d0f2e67d00ffb809319fb84bc81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable.html#a70e53d0f2e67d00ffb809319fb84bc81">broadcast</a> (void)</td></tr>
<tr class="memdesc:a70e53d0f2e67d00ffb809319fb84bc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify all threads waiting for a condition variable.  <br /></td></tr>
<tr class="separator:a70e53d0f2e67d00ffb809319fb84bc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac920555b675c7778d8db780307fdcd3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable.html#ac920555b675c7778d8db780307fdcd3d">wait</a> (<a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a> &amp;<a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a>)</td></tr>
<tr class="memdesc:ac920555b675c7778d8db780307fdcd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a condition variable to be notified.  <br /></td></tr>
<tr class="separator:ac920555b675c7778d8db780307fdcd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea63b3c19dd9e0fa2f17c781ec220198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1condition__variable.html#aea63b3c19dd9e0fa2f17c781ec220198">timed_wait</a> (<a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a> &amp;<a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a>, <a class="el" href="group__cmsis-plus-rtos-clock.html#ga149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a> timeout)</td></tr>
<tr class="memdesc:aea63b3c19dd9e0fa2f17c781ec220198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed wait for a condition variable to be notified.  <br /></td></tr>
<tr class="separator:aea63b3c19dd9e0fa2f17c781ec220198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Member Functions</div></td></tr>
<tr class="memitem:a3103a84c5e0521c3639306f5879526ba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named.html#a3103a84c5e0521c3639306f5879526ba">name</a> (void) const</td></tr>
<tr class="memdesc:a3103a84c5e0521c3639306f5879526ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get object name.  <br /></td></tr>
<tr class="separator:a3103a84c5e0521c3639306f5879526ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a1456983acc3a56e02cd4a48a220f222c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c">operator new</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a1456983acc3a56e02cd4a48a220f222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a new object instance using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:a1456983acc3a56e02cd4a48a220f222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f709b685919d096e49acb8edefe02f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a35f709b685919d096e49acb8edefe02f">operator new</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:a35f709b685919d096e49acb8edefe02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace a new object instance.  <br /></td></tr>
<tr class="separator:a35f709b685919d096e49acb8edefe02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27026070d8fd2c51873036cfd1661ce4"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a27026070d8fd2c51873036cfd1661ce4">operator new[]</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a27026070d8fd2c51873036cfd1661ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for an array of new object instances using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:a27026070d8fd2c51873036cfd1661ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#ad415429ae3487ec5ae1258b4d2a5787f">operator new[]</a> (std::size_t bytes, void *ptr)</td></tr>
<tr class="memdesc:ad415429ae3487ec5ae1258b4d2a5787f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace an array of new object instances.  <br /></td></tr>
<tr class="separator:ad415429ae3487ec5ae1258b4d2a5787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#aef5d78f2ac3f37daf3984758c9e2ddb2">operator delete</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated object instance. using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:aef5d78f2ac3f37daf3984758c9e2ddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c29f4a020deee857f22330e0277ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#adc1c29f4a020deee857f22330e0277ed">operator delete[]</a> (void *ptr, std::size_t bytes)</td></tr>
<tr class="memdesc:adc1c29f4a020deee857f22330e0277ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the dynamically allocated array of object. instances using the RTOS system allocator.  <br /></td></tr>
<tr class="separator:adc1c29f4a020deee857f22330e0277ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ga33e431621c631497db5d26dc4736d51d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classos_1_1rtos_1_1condition__variable_1_1attributes.html">attributes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmsis-plus-rtos-condvar.html#ga33e431621c631497db5d26dc4736d51d">initializer</a></td></tr>
<tr class="memdesc:ga33e431621c631497db5d26dc4736d51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default condition variable initialiser.  <br /></td></tr>
<tr class="separator:ga33e431621c631497db5d26dc4736d51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>POSIX compliant <b>condition variable</b>. </p>
<p>A condition variable is a synchronisation object which allows a thread to suspend execution, repeatedly, until some associated predicate becomes true. A thread whose execution is suspended on a condition variable is said to be blocked on the condition variable.</p>
<dl class="section user"><dt>Scheduling Behaviour of Condition Variables</dt><dd></dd></dl>
<p>Synchronisation primitives that attempt to interfere with scheduling policy by specifying an ordering rule are considered undesirable. Threads waiting on mutexes and condition variables are selected to proceed in an order dependent upon the scheduling policy rather than in some fixed order (for example, FIFO or priority). Thus, the scheduling policy determines which <a class="el" href="classthread.html" title="Standard thread.">thread(s)</a> are awakened and allowed to proceed.</p>
<dl class="section user"><dt>Cancellation and Condition Wait</dt><dd></dd></dl>
<p>A condition wait, whether timed or not, is a cancellation point. That is, the functions <code><a class="el" href="classos_1_1rtos_1_1condition__variable.html#ac920555b675c7778d8db780307fdcd3d" title="Wait for a condition variable to be notified.">wait()</a></code> or <code><a class="el" href="classos_1_1rtos_1_1condition__variable.html#aea63b3c19dd9e0fa2f17c781ec220198" title="Timed wait for a condition variable to be notified.">timed_wait()</a></code> are points where a pending (or concurrent) cancellation request is noticed. The reason for this is that an indefinite wait is possible at these points-whatever event is being waited for, even if the program is totally correct, might never occur; for example, some input data being awaited might never be sent. By making condition wait a cancellation point, the thread can be cancelled and perform its cancellation cleanup handler even though it may be stuck in some indefinite wait.</p>
<p>A side-effect of acting on a cancellation request while a thread is blocked on a condition variable is to re-acquire the mutex before calling any of the cancellation cleanup handlers. This is done in order to ensure that the cancellation cleanup handler is executed in the same state as the critical code that lies both before and after the call to the condition wait function. This rule is also required when interfacing to POSIX threads from languages, such as Ada or C++, which may choose to map cancellation onto a language exception; this rule ensures that each exception handler guarding a critical section can always safely depend upon the fact that the associated mutex has already been locked regardless of exactly where within the critical section the exception was raised. Without this rule, there would not be a uniform rule that exception handlers could follow regarding the lock, and so coding would become very cumbersome.</p>
<p>Therefore, since some statement has to be made regarding the state of the lock when a cancellation is delivered during a wait, a definition has been chosen that makes application coding most convenient and error free.</p>
<p>When acting on a cancellation request while a thread is blocked on a condition variable, the implementation is required to ensure that the thread does not consume any condition signals directed at that condition variable if there are any other threads waiting on that condition variable. This rule is specified in order to avoid deadlock conditions that could occur if these two independent requests (one acting on a thread and the other acting on the condition variable) were not processed independently.</p>
<dl class="section user"><dt>Performance of Mutexes and Condition Variables</dt><dd></dd></dl>
<p>Mutexes are expected to be locked only for a few instructions. This practice is almost automatically enforced by the desire of programmers to avoid long serial regions of execution (which would reduce total effective parallelism).</p>
<p>When using mutexes and condition variables, one tries to ensure that the usual case is to lock the mutex, access shared data, and unlock the mutex. Waiting on a condition variable should be a relatively rare situation. For example, when implementing a read-write lock, code that acquires a read-lock typically needs only to increment the count of readers (under mutual-exclusion) and return. The calling thread would actually wait on the condition variable only when there is already an active writer. So the efficiency of a synchronisation operation is bounded by the cost of mutex lock/unlock and not by condition wait. Note that in the usual case there is no context switch.</p>
<p>This is not to say that the efficiency of condition waiting is unimportant. Since there needs to be at least one context switch per Ada rendezvous, the efficiency of waiting on a condition variable is important. The cost of waiting on a condition variable should be little more than the minimal cost for a context switch plus the time to unlock and lock the mutex.</p>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a class="code hl_class" href="classos_1_1rtos_1_1mutex.html">mutex</a> mx;</div>
<div class="line"><a class="code hl_class" href="classos_1_1rtos_1_1condition__variable.html">condition_variable</a> cv;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">consumer(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Do something</span></div>
<div class="line">  mx.<a class="code hl_function" href="classos_1_1rtos_1_1mutex.html#a0fd459d4da59662256bbd807b73c263e">lock</a>();</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  <span class="keywordflow">while</span>(!condition())</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">      cv.<a class="code hl_function" href="classos_1_1rtos_1_1condition__variable.html#ac920555b675c7778d8db780307fdcd3d">wait</a>();</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  mx.<a class="code hl_function" href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb">unlock</a>(mx);</div>
<div class="line">  <span class="comment">// Do something else.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">producer(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Do something</span></div>
<div class="line">  mx.<a class="code hl_function" href="classos_1_1rtos_1_1mutex.html#a0fd459d4da59662256bbd807b73c263e">lock</a>();</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  <span class="keywordflow">if</span> (some_condition())</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">      cv.<a class="code hl_function" href="classos_1_1rtos_1_1condition__variable.html#a2cee82ef11f1690e478733a1d7abe766">signal</a>();</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  mx.<a class="code hl_function" href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb">unlock</a>(mx);</div>
<div class="line">  <span class="comment">// Do something else.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassos_1_1rtos_1_1condition__variable_html"><div class="ttname"><a href="classos_1_1rtos_1_1condition__variable.html">os::rtos::condition_variable</a></div><div class="ttdoc">POSIX compliant condition variable.</div><div class="ttdef"><b>Definition</b> <a href="os-condvar_8h_source.html#l00051">os-condvar.h:52</a></div></div>
<div class="ttc" id="aclassos_1_1rtos_1_1condition__variable_html_a2cee82ef11f1690e478733a1d7abe766"><div class="ttname"><a href="classos_1_1rtos_1_1condition__variable.html#a2cee82ef11f1690e478733a1d7abe766">os::rtos::condition_variable::signal</a></div><div class="ttdeci">result_t signal(void)</div><div class="ttdoc">Notify one thread waiting for a condition variable.</div></div>
<div class="ttc" id="aclassos_1_1rtos_1_1condition__variable_html_ac920555b675c7778d8db780307fdcd3d"><div class="ttname"><a href="classos_1_1rtos_1_1condition__variable.html#ac920555b675c7778d8db780307fdcd3d">os::rtos::condition_variable::wait</a></div><div class="ttdeci">result_t wait(mutex &amp;mutex)</div><div class="ttdoc">Wait for a condition variable to be notified.</div></div>
<div class="ttc" id="aclassos_1_1rtos_1_1mutex_html"><div class="ttname"><a href="classos_1_1rtos_1_1mutex.html">os::rtos::mutex</a></div><div class="ttdoc">POSIX compliant mutex.</div><div class="ttdef"><b>Definition</b> <a href="os-mutex_8h_source.html#l00053">os-mutex.h:54</a></div></div>
<div class="ttc" id="aclassos_1_1rtos_1_1mutex_html_a0fd459d4da59662256bbd807b73c263e"><div class="ttname"><a href="classos_1_1rtos_1_1mutex.html#a0fd459d4da59662256bbd807b73c263e">os::rtos::mutex::lock</a></div><div class="ttdeci">result_t lock(void)</div><div class="ttdoc">Lock/acquire the mutex.</div><div class="ttdef"><b>Definition</b> <a href="os-mutex_8cpp_source.html#l00918">os-mutex.cpp:918</a></div></div>
<div class="ttc" id="aclassos_1_1rtos_1_1mutex_html_afeb6e546c4dc95c96d8f81aba64638cb"><div class="ttname"><a href="classos_1_1rtos_1_1mutex.html#afeb6e546c4dc95c96d8f81aba64638cb">os::rtos::mutex::unlock</a></div><div class="ttdeci">result_t unlock(void)</div><div class="ttdoc">Unlock/release the mutex.</div><div class="ttdef"><b>Definition</b> <a href="os-mutex_8cpp_source.html#l01275">os-mutex.cpp:1275</a></div></div>
</div><!-- fragment --><dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <code>pthread_cond_t</code> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-condvar_8h_source.html#l00051">51</a> of file <a class="el" href="os-condvar_8h_source.html">os-condvar.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad61db5c36f5744c8d020dac53a55cd65" name="ad61db5c36f5744c8d020dac53a55cd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61db5c36f5744c8d020dac53a55cd65">&#9670;&#160;</a></span>condition_variable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::condition_variable::condition_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1condition__variable_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="group__cmsis-plus-rtos-condvar.html#ga33e431621c631497db5d26dc4736d51d">initializer</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a condition variable object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The constructor shall fail if:<ul>
<li><code>EAGAIN</code> - The system lacked the necessary resources (other than memory) to create the condition variable.</li>
<li><code>ENOMEM</code> - Insufficient memory exists to initialise the condition variable. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The constructor shall not fail with an error code of <code>EINTR</code>.</dd></dl>
<p>This constructor shall initialise a condition variable object with attributes referenced by <em>attr</em>. If the attributes specified by <em>attr</em> are modified later, the condition variable attributes shall not be affected.</p>
<p>Upon successful initialisation, the state of the condition variable object shall become initialised.</p>
<p>Only the condition variable object itself may be used for performing synchronisation. It is not allowed to make copies of condition variable objects.</p>
<p>In cases where default condition variable attributes are appropriate, the variable <code><a class="el" href="group__cmsis-plus-rtos-condvar.html#ga33e431621c631497db5d26dc4736d51d" title="Default condition variable initialiser.">condition_variable::initializer</a></code> can be used to initialise condition variables. The effect shall be equivalent to creating a condition variables object with the default constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines.</dd></dl>
<dl class="section user"><dt>POSIX compatibility</dt><dd>Inspired by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_destroy.html"><code>pthread_cond_init()</code></a> from <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html"><code>&lt;pthread.h&gt;</code></a> (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/nframe.html">IEEE Std 1003.1, 2013 Edition</a>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-condvar_8cpp_source.html#l00226">226</a> of file <a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a>.</p>

</div>
</div>
<a id="af745a5ce4a56cfad74cc67d4aab9a688" name="af745a5ce4a56cfad74cc67d4aab9a688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af745a5ce4a56cfad74cc67d4aab9a688">&#9670;&#160;</a></span>condition_variable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::condition_variable::condition_variable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1condition__variable_1_1attributes.html">attributes</a> &amp;&#160;</td>
          <td class="paramname"><em>attr</em> = <code><a class="el" href="group__cmsis-plus-rtos-condvar.html#ga33e431621c631497db5d26dc4736d51d">initializer</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a named condition variable object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attr</td><td>Reference to attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The constructor shall fail if:<ul>
<li><code>EAGAIN</code> - The system lacked the necessary resources (other than memory) to create the condition variable.</li>
<li><code>ENOMEM</code> - Insufficient memory exists to initialise the condition variable. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>The constructor shall not fail with an error code of <code>EINTR</code>. </dd></dl>

</div>
</div>
<a id="adaa0dad7f07e3fbc6f2ff8bd865bd0df" name="adaa0dad7f07e3fbc6f2ff8bd865bd0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa0dad7f07e3fbc6f2ff8bd865bd0df">&#9670;&#160;</a></span>~condition_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os::rtos::condition_variable::~condition_variable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct the condition variable object instance. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a70e53d0f2e67d00ffb809319fb84bc81" name="a70e53d0f2e67d00ffb809319fb84bc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e53d0f2e67d00ffb809319fb84bc81">&#9670;&#160;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::condition_variable::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify all threads waiting for a condition variable. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>All waiting threads signalled. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The function shall not fail with an error code of <code>EINTR</code>. </dd></dl>

</div>
</div>
<a id="a3103a84c5e0521c3639306f5879526ba" name="a3103a84c5e0521c3639306f5879526ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3103a84c5e0521c3639306f5879526ba">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * os::rtos::internal::object_named::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get object name. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A null terminated string.</dd></dl>
<p>All objects return a non-null string; anonymous objects return <code>"-"</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Can be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-decls_8h_source.html#l00760">760</a> of file <a class="el" href="os-decls_8h_source.html">os-decls.h</a>.</p>

</div>
</div>
<a id="aef5d78f2ac3f37daf3984758c9e2ddb2" name="aef5d78f2ac3f37daf3984758c9e2ddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d78f2ac3f37daf3984758c9e2ddb2">&#9670;&#160;</a></span>operator delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated object instance. using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p><em>ptr</em> shall be a null pointer or its value shall be a value returned by an earlier call to the (possibly replaced) <a class="el" href="classos_1_1rtos_1_1internal_1_1object__named__system.html#a1456983acc3a56e02cd4a48a220f222c" title="Allocate space for a new object instance using the RTOS system allocator.">operator new()</a> which has not been invalidated by an intervening call to operator delete(void*).</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00134">134</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="adc1c29f4a020deee857f22330e0277ed" name="adc1c29f4a020deee857f22330e0277ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1c29f4a020deee857f22330e0277ed">&#9670;&#160;</a></span>operator delete[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void os::rtos::internal::object_named_system::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the dynamically allocated array of object. instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to array of objects. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes to deallocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>The deallocation function (3.7.4.2) called by the array form of a delete-expression to render the value of <em>ptr</em> invalid.</p>
<p>If <em>ptr</em> is null, does nothing. Otherwise, reclaims the storage allocated by the earlier call to operator new.</p>
<p>The storage is deallocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00155">155</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a1456983acc3a56e02cd4a48a220f222c" name="a1456983acc3a56e02cd4a48a220f222c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1456983acc3a56e02cd4a48a220f222c">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for a new object instance using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00056">56</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a35f709b685919d096e49acb8edefe02f" name="a35f709b685919d096e49acb8edefe02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f709b685919d096e49acb8edefe02f">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace a new object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced object.</dd></dl>
<p>The allocation function (3.7.4.1) called by a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any object of that size. Return a non-null pointer to suitably aligned storage (3.7.4).</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00093">93</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="a27026070d8fd2c51873036cfd1661ce4" name="a27026070d8fd2c51873036cfd1661ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27026070d8fd2c51873036cfd1661ce4">&#9670;&#160;</a></span>operator new[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for an array of new object instances using the RTOS system allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00074">74</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="ad415429ae3487ec5ae1258b4d2a5787f" name="ad415429ae3487ec5ae1258b4d2a5787f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad415429ae3487ec5ae1258b4d2a5787f">&#9670;&#160;</a></span>operator new[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * os::rtos::internal::object_named_system::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplace an array of new object instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to emplace. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to location to emplace the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to emplaced array.</dd></dl>
<p>The allocation function (3.7.4.1) called by the array form of a placement new-expression to allocate a storage of size <em>bytes</em> suitably aligned to represent any array object of that size or smaller.</p>
<p>The storage is allocated using the RTOS system allocator.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cannot be invoked from Interrupt Service Routines. </dd></dl>

<p class="definition">Definition at line <a class="el" href="os-inlines_8h_source.html#l00110">110</a> of file <a class="el" href="os-inlines_8h_source.html">os-inlines.h</a>.</p>

</div>
</div>
<a id="ad63aece1e3bb6cf91a89f3923361d503" name="ad63aece1e3bb6cf91a89f3923361d503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63aece1e3bb6cf91a89f3923361d503">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool os::rtos::condition_variable::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classos_1_1rtos_1_1condition__variable.html">condition_variable</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare condition variables. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The given condition variable is the same as this condition variable. </td></tr>
    <tr><td class="paramname">false</td><td>The condition variables are different.</td></tr>
  </table>
  </dd>
</dl>
<p>Identical condition variables should have the same memory address. </p>

<p class="definition">Definition at line <a class="el" href="os-condvar_8h_source.html#l00326">326</a> of file <a class="el" href="os-condvar_8h_source.html">os-condvar.h</a>.</p>

</div>
</div>
<a id="a2cee82ef11f1690e478733a1d7abe766" name="a2cee82ef11f1690e478733a1d7abe766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cee82ef11f1690e478733a1d7abe766">&#9670;&#160;</a></span>signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::condition_variable::signal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify one thread waiting for a condition variable. </p>
<dl class="section user"><dt>Parameters</dt><dd>None. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The thread was signalled. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The function shall not fail with an error code of <code>EINTR</code>. </dd></dl>

</div>
</div>
<a id="aea63b3c19dd9e0fa2f17c781ec220198" name="aea63b3c19dd9e0fa2f17c781ec220198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea63b3c19dd9e0fa2f17c781ec220198">&#9670;&#160;</a></span>timed_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::condition_variable::timed_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cmsis-plus-rtos-clock.html#ga149d8b5cea55224ef5cfede8a81df04c">clock::duration_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed wait for a condition variable to be notified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Reference to the associated mutex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The condition change was signalled. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines, or the mutex type is <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9a77c021f70c077e034edf3044329c2d26" title="Check mutex behaviour.">mutex::type::errorcheck</a></code> or the mutex is a robust mutex, and the current thread does not own the mutex. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
    <tr><td class="paramname">ETIMEDOUT</td><td>The timeout has passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The function shall not fail with an error code of <code>EINTR</code>. </dd></dl>

</div>
</div>
<a id="ac920555b675c7778d8db780307fdcd3d" name="ac920555b675c7778d8db780307fdcd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac920555b675c7778d8db780307fdcd3d">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceos_1_1rtos.html#a54633089ccffe9e56ce1137ebe57776d">result_t</a> os::rtos::condition_variable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classos_1_1rtos_1_1mutex.html">mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a condition variable to be notified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Reference to the associated mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="namespaceos_1_1rtos_1_1result.html#a1f5b41a48ca4ac9f7aeb3bd1c702b45aac3daa6d58a1202b112a91628d144685b" title="Function completed; no errors or events occurred.">result::ok</a></td><td>The condition change was signalled. </td></tr>
    <tr><td class="paramname">EPERM</td><td>Cannot be invoked from an Interrupt Service Routines, or the mutex type is <code><a class="el" href="structos_1_1rtos_1_1mutex_1_1type.html#a236f83dd04e1c18f388949b26fe5f4b9a77c021f70c077e034edf3044329c2d26" title="Check mutex behaviour.">mutex::type::errorcheck</a></code> or the mutex is a robust mutex, and the current thread does not own the mutex. </td></tr>
    <tr><td class="paramname">ENOTRECOVERABLE</td><td>The state protected by the mutex is not recoverable. </td></tr>
    <tr><td class="paramname">EOWNERDEAD</td><td>The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors</dt><dd>The function shall not fail with an error code of <code>EINTR</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="os-condvar_8h_source.html">os-condvar.h</a></li>
<li><a class="el" href="os-condvar_8cpp_source.html">os-condvar.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceos.html">os</a></li><li class="navelem"><a class="el" href="namespaceos_1_1rtos.html">rtos</a></li><li class="navelem"><a class="el" href="classos_1_1rtos_1_1condition__variable.html">condition_variable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
