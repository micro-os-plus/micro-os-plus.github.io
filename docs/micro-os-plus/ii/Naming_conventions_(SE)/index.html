<!doctype html>

<html lang="en">


<head>

  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Naming conventions (SE)</title>
  <meta name="description" content="The third edition of µOS++, a POSIX inspired open source framework, written in C++.">

  <meta property="og:title" content="Naming conventions (SE)" />
  <meta property="og:site_name" content="µOS++ IIIe" />

  <link rel="alternate" type="application/rss+xml" title="µOS++ IIIe" href="/feed.xml" />


  <meta property="article:published_time" content="2014-02-22">





  <meta name="google-site-verification" content="NT_y3tqI_8mrd8gYA_FDWHT2-tkJExOC6KBkSnyZx6c" />

  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" type="text/css" href="/stylesheets/screen.css?202211100849" media="screen">
  <link rel="stylesheet" type="text/css" href="/stylesheets/font-awesome.css?202211100849" media="screen">
  <link rel="stylesheet" type="text/css" href="/stylesheets/print.css?202211100849" media="print">

  <link rel="canonical" href="/micro-os-plus/ii/Naming_conventions_(SE)/">



  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9T84WD3CK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E9T84WD3CK');
</script>



</head>


<body>

<div class="container">

  <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

  <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

  <div class="site-header">
  <table style="width:100%">
    <tr>
      <td>
        <a href="/">
          <img alt="Icon" class="site-icon" src="/assets/icons/wall-e-icon.png" height="100" width="100">
      </a>
      </td>
      <td>
        <table class="site-title" style="width:100%">
          <tr>
            <td class="site-title">
              <a href="/">µOS++ IIIe</a>
            </td>
            <td class="site-motto" align="right">
              “Perfekt ist nicht gut genug”
            </td>
          </tr>
          <tr>
            <td class="site-description" colspan="2">
              The third edition of µOS++, a POSIX inspired open source framework, written in C++.
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</div>


</div>

<div class="container">

  <div class="wrapper">
    <div class="site-body">

      <div class="site-sidebar">


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      <h4 id="news"><a href="/blog/">News</a></h4>

<ul>
  <li><a href="/blog/2021/01/22/micro-os-plus-first-scriptable-build/">First µOS++ scriptable build</a></li>
  <li><a href="/blog/2018/11/19/micro-os-plus-v6-3-15-released/">µOS++ IIIe v6.3.15 released</a></li>
  <li><a href="/blog/2018/07/04/micro-os-plus-v6-3-14-released/">µOS++ IIIe v6.3.14 released</a></li>
  <li><a href="/blog/2017/08/26/micro-os-plus-v6-3-13-released/">µOS++ IIIe v6.3.13 released</a></li>
</ul>


    </div>
  </div>


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      
      <h4 id="home"><a href="/">Home</a></h4>

<h4 id="µos-iiie">µOS++ IIIe</h4>

<ul>
  <li><a href="/micro-os-plus/">Overview</a></li>
</ul>

<h4 id="apis">APIs</h4>

<ul>
  <li><a href="/cmsis-plus/">Overview</a></li>
  <li><a href="/cmsis-plus/rtos/">RTOS API</a></li>
</ul>

<h4 id="xpacksxcdl">xPacks/XCDL</h4>

<ul>
  <li><a href="/xpacks/">Overview</a></li>
</ul>

<h4 id="documentation">Documentation</h4>

<ul>
  <li>
<a href="/user-manual/">User’s <strong>manual</strong></a>
    <ul>
      <li><a href="/user-manual/getting-started/">Getting started</a></li>
      <li><a href="/user-manual/basic-concepts/">Basic concepts</a></li>
      <li><a href="/user-manual/features/">Features</a></li>
      <li><a href="/user-manual/threads/">Threads</a></li>
      <li><a href="/user-manual/thread-event-flags/">Thread event flags</a></li>
      <li><a href="/user-manual/semaphores/">Semaphores</a></li>
      <li><a href="/user-manual/event-flags/">Event flags</a></li>
      <li>Mutexes</li>
      <li>Condition variables</li>
      <li>Message queues</li>
      <li>Memory pools</li>
      <li>Software timers</li>
      <li>Clocks</li>
    </ul>
  </li>
  <li><a href="/reference/cmsis-plus/">µOS++ <strong>reference</strong></a></li>
</ul>

<h4 id="developer">Developer</h4>

<ul>
  <li><a href="/develop/">Overview</a></li>
  <li><a href="/reference/cmsis-plus/md_doxygen_pages_change-log.html">Change log</a></li>
  <li><a href="/develop/coding-style/">C++ coding style</a></li>
  <li><a href="/develop/naming-conventions/">Naming conventions</a></li>
  <li><a href="/develop/references/">Links &amp; references</a></li>
</ul>

<h4 id="support">Support</h4>

<ul>
  <li><a href="/support/">Overview</a></li>
  <li><a href="/support/known-issues/">Known issues</a></li>
  <li><a href="/support/faq/">FAQ</a></li>
  <li><a href="/support/forum/">Forum</a></li>
  <li><a href="https://github.com/micro-os-plus/micro-os-plus-iii/issues/">Report µOS++ IIIe issues</a></li>
</ul>

<h4 id="latest-articles">Latest Articles</h4>

<ul>
  <li><a href="/articles/arm-com-2016-06-24/">CMSIS++ RTOS: fully functional reference implementation</a></li>
  <li><a href="/articles/arm-com-2016-03-11/">CMSIS++: a proposal for a future CMSIS, written in C++</a></li>
</ul>

<h4 id="project">Project</h4>

<ul>
  <li><a href="/project/about/">About</a></li>
  <li><a href="/project/history/">History</a></li>
  <li><a href="https://opensource.org/licenses/MIT">License</a></li>
</ul>

    </div>
  </div>

  <div class="site-theme">
    This site uses the <a href="https://github.com/ilg-ul/github-jekyll-theme">GitHub Wiki-like</a> theme by <a href="https://github.com/ilg-ul">Liviu Ionescu</a>.
  </div>

</div>


      <div class="site-content">

        
<h1 class="page-title">Naming conventions (SE) - DEPRECATED</h1>
<table id="last-modified">
  <tr>
    <td id="last-modified">Page date Sat Feb 22 16:02:04 2014 .</td>
    <td id="improve" align="right"><a id="improve" href="https://github.com/micro-os-plus/web-jekyll/edit/master/pages/micro-os-plus/ii/Naming_conventions_(SE).md"><i class="fa fa-pencil"></i>  Improve this page</a></td>
  </tr>
</table>

<p>µOS++ uses the common C++ naming convention, based on the <a href="http://en.wikipedia.org/wiki/CamelCase">CamelCase</a> convention.</p>

<h1 id="full-words-vs-short-words">Full words vs. short words</h1>

<p>Whenever possible, it is recommended to use the full words; shortening words in member or member function names does not make the program shorter or faster, but, when used properly, highly increases the readability of the program.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int initialise(); &lt;- instead of init();
int configure(); &lt;- instead of config();
...
int delaySeconds; &lt;- instead of delaySec;
</code></pre></div></div>

<h1 id="pairs-of-opposed-actions-or-names">Pairs of opposed actions or names</h1>

<h2 id="antonyms">Antonyms</h2>

<p>When defining pairs of opposed actions, use the proper antonyms:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int startAcquisition();
int stopAcquisition();
...
int enableInterrupts();
int disableInterrupts();
</code></pre></div></div>

<h2 id="technical-terms">Technical terms</h2>

<p>Sometimes, even if the words are not listed in dictionaries as antonyms, the pairs of opposed names are defined by practice:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// For hardware signals, like chip select
int assert();
int deassert();
...
// For synchronisation objects, like mutex
int acquire();
int release();
</code></pre></div></div>

<h2 id="startstop-vs-beginend">start/stop vs. begin/end</h2>

<p>When defining actions, prefer <strong>start</strong>/<strong>stop</strong> to <strong>begin</strong>/<strong>end</strong>, since they have a stronger verb-like meaning (end is more an adjective than a verb).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int startAcquisition(); &lt;- instead of beginAcquisition()
int stopAcquisition(); &lt;- instead of endAcquisition()
</code></pre></div></div>

<p>However, when the meaning is adjectival, for example adding determinants to a noun, the pair begin/end is preferred.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int listBegin; &lt;- instead of listStart
int listEnd; &lt;- instead of listStop
</code></pre></div></div>

<h1 id="class-names">Class names</h1>

<p>Class names start with upper case letters, and are singular names or nominative constructs.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Logger;
class CircularBuffer;
</code></pre></div></div>

<h2 id="derived-class-names">Derived class names</h2>

<p>Derived class names should extend the base class name, by adding a differentiator at one end.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class OSDeviceCharacterBuffered : public OSDeviceCharacter
{
 ...
};
</code></pre></div></div>

<h2 id="abstract-base-classes">Abstract base classes</h2>

<p>When an abstract class is used as a base class for concrete implementations, the word Base can be used in the name, and this name can be skipped in the derived class name:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class DeviceCharacterBufferedUsart0 : public DeviceCharacterBufferedBase
{
 ...
};
</code></pre></div></div>

<h1 id="templates">Templates</h1>

<p>Templates are a great C++ feature, that can be used for many purposes, with the common one being to implement compile time polymorphism.</p>

<h2 id="template-class-names">Template class names</h2>

<p>Template class names follow the same convention as the class names, but are prefixed with an upper case ‘T’.</p>

<p>When instantiated, obviously the instance names drop the initial ‘T’.</p>

<h2 id="template-parameter-types">Template parameter types</h2>

<p>There are several template parameter types, parameters naming user-defined types (like classes), parameters naming primitive types and constant parameters (usually integer).</p>

<p>Although not required by the language, it is recommended to define parameters naming user-defined types with <strong>class Name_T</strong> and parameters naming primitive types <strong>typename Name_T</strong>.</p>

<p>In class templates, it is recommended to alias the template parameters to new names, and use these new names in code, reserving the template parameters only to define the template syntax.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;class GPIO_T, typename Result_T = void, int Bit_T&gt;
class TPin
{
public:
  typedef GPIO_T GPIO;
  typedef Result_T result_t;
  static const int bit = Bit_T;
 ...
}

// Explicit instantiation
template class TPin&lt;GPIOC1&gt;;
typename class TPin&lt;GPIOC1&gt; Pin;
</code></pre></div></div>

<h1 id="member-function-names">Member function names</h1>

<p>All member function names start with lower case letters.</p>

<p>Since functions define actions to be performed upon the object, the function name should have the function of a predicate, and usually <strong>start with an imperative verb</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int read();
</code></pre></div></div>

<p>If there are multiple functions that perform similar actions, they should differentiate by the following noun, with the function of a direct complement.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int readByte();
long readLong();
...
void readBlock();
</code></pre></div></div>

<p>The rule of starting with a verb is not absolute, when multiple functions are logically grouped by a common criteria, then predicative groups can be used as function names, and the verb is placed at the end.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool eventWaitPrepare(OSEvent_t event);
OSEventWaitReturn_t eventWaitPerform(void);

int eventNotify(OSEvent_t event, OSEventWaitReturn_t ret = OSEventWaitReturn::OS_VOID);
</code></pre></div></div>

<p>However, when such names occur, it might be a sign that the design can be further refined by defining additional objects, for example instead of</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void criticalEnter();
void criticalExit();
</code></pre></div></div>

<p>in the new version of µOS++ we use a separate object to manage critical sections, like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class OSCriticalSection
{
  void enter(void);
  void exit(void);
};
</code></pre></div></div>

<p>In this case the naming convention is again simplified, according to the initial recommendation to use a verb.</p>

<h2 id="getterssetters">Getters/Setters</h2>

<p>As in most object oriented designs, member variables are usually private to the class and external direct access to them is discouraged. Instead, special getters and setters should be defined.</p>

<p>The name should contain exactly the variable name, prefixed with <strong>get</strong> or <strong>set</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private:
  int m_count;

public:
  int getCount(void);
  void setCount(int);
</code></pre></div></div>

<h2 id="getset-vs-readwrite">get/set vs. read/write</h2>

<p>When dealing with hardware, even if the memory mapped registers are seen as class members, it is recommended to prefix member functions with read/write, not get/set, which should be used only for accessing private data members of usual objects.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hal::cortexm::reg32_t
readMode(void);

void
writeMode(const hal::cortexm::reg32_t value);
</code></pre></div></div>

<h2 id="boolean-functions">Boolean functions</h2>

<p>Functions that return boolean values should start with boolean verbs, like <strong>is</strong>, <strong>has</strong>, <strong>does</strong>. Depending on the context, past or future tense versions, like <strong>was</strong> or <strong>will</strong> may be more appropriate.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool isAvailable();
bool wasInterrupted();
bool willBlock();
bool hasMembers();
bool doesReturn();  &lt;-- instead of 'bool returns();'
</code></pre></div></div>

<h2 id="initialise-vs-configure">initialise() vs. configure()</h2>

<p>In classes implementing device drivers, there are member functions that can be called only before the device is enabled and functions that can be called at any moment.</p>

<p>To mark this distinction, the recommended names should start with <strong>initialise</strong> for functions that are used before the device is enabled and with <strong>configure</strong> for functions that can be used at any moment.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool initialiseSomething(void);
...
bool configureBaudRate(BaudRate_t baudRate);
bool configureHighSpeed(void);
</code></pre></div></div>

<p>It is recommended to use the full words, shortening initialise() to init() or configure() to config() does not make the program shorter or faster.</p>

<h2 id="set-vs-configure">set() vs. configure()</h2>

<p>As mentioned before, setMember() generally should be used as a setter for a class member variable. When dealing with device drivers, changing the state of the device is in fact a configuration change, so it is more appropriate to name functions like configureSomething().</p>

<h1 id="member-variables-names">Member variables names</h1>

<p>Similar to member functions, all member variables names start with lower case letters.</p>

<p>Since member variables define characteristics of the object, the member variables name should have the function of an attribute, and usually <strong>start with a noun</strong>. Boolean status variables naming convention should follow the boolean function naming convention, i.e. start with a verb like <strong>is</strong>, <strong>has</strong>, <strong>does</strong>, at present/past/future tense.</p>

<h2 id="private-member-variables-names">Private member variables names</h2>

<p>As the most common type of member variable names, the private member variables should be prefixed with <strong>m_</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private:
  int m_count;
  char* m_bufferAddress;
  int m_bufferSize;

  bool m_isRunning;
  bool m_wasCancelled;
</code></pre></div></div>

<h2 id="static-member-variables-names">Static member variables names</h2>

<p>Static member variables should be prefixed with <strong>ms_</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static OSThread* volatile ms_pThreadRunning;
</code></pre></div></div>

<h2 id="public-member-names">Public member names</h2>

<p>As an exception to the above rules, some globally available member variables, like those in the global <strong>os</strong> or <strong>app</strong> objects, can be named without the <strong>m_</strong> prefix.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class OS : public OSImpl
{
public:
  ...
  OSScheduler sched;
  ...
};
</code></pre></div></div>

<h2 id="array-members">Array members</h2>

<p>For a better code readability, it is recommended to name array members or pointers to arrays explicitly, like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OSTask** m_pWaitingTasksArray;
unsigned short m_waitingTasksArraySize;
</code></pre></div></div>

<h1 id="const--volatile">const &amp; volatile</h1>

<p>The rules for using these keywords are sometimes tricky, and the easiest to remember is <em>const makes a constant whatever is on its left</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> int* const p1; // constant pointer to int
 const int* p2; // pointer to an int constant
 const int* const p3; // constant pointer to an int constant
</code></pre></div></div>

<p>Systematic use of the above rule would put the type of scalars at the left of const, which is not that usual:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> int const n; // constant integer
</code></pre></div></div>

<p>So, for scalars and for constants, it is also acceptable to use the more common order:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> const int n;
 static const int CONST = 7;
</code></pre></div></div>

<h1 id="constants">Constants</h1>

<p>Constant names are all upper case, with words separated by underscores, as in most C programs.</p>

<p>Although in C/C++ it is possible to define constants using the preprocessor, it is recommended to use them only for project configuration variables, otherwise use only typed definitions, and the compiler might catch some errors.</p>

<p>For individual definitions, the recommended way is to use <strong>constexpr</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constexpr threadId_t NO_ID = 0xFF;
</code></pre></div></div>

<p>For definitions inside a class, use <strong>static constexpr</strong> members.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static constexpr OSReturn_t OS_OK = 0;
</code></pre></div></div>

<p>Depending on the specific scope, if the constants are to be used only inside the given class, they can be made private.</p>

<p>Constants can be grouped in separated classes, like the system OSReturn class, that groups together various return values, although enums would be probably more appropriate.</p>

<p>For group of constants, the recommended method is to use <a href="/micro-os-plus/ii/Naming_conventions_(SE)/#enumeration-definitions">class enumerations</a>.</p>

<h2 id="static-constexpr-vs-constexpr-static">static constexpr vs. constexpr static</h2>

<p>The recommended order is <strong>static constexpr</strong>.</p>

<h1 id="type-definitions">Type definitions</h1>

<p>For a better code maintainability, where needed, it is recommended to use type definitions instead of direct C/C++ scalar types.</p>

<p>Scalar type definitions should start with lower case letters and end with <strong>_t</strong>; class aliases should follow the usual naming convention of class names.</p>

<h2 id="language-type-definition">Language type definition</h2>

<h3 id="explicit-size-definitions">Explicit size definitions</h3>

<p>These are mainly the definitions from <stdint.h></stdint.h></p>

<ul>
  <li>
<strong>uint8_t</strong>, <strong>int8_t</strong>
</li>
  <li>
<strong>uint16_t</strong>, <strong>int16_t</strong>
</li>
  <li>
<strong>uint32_t</strong>, <strong>int32_t</strong>
</li>
</ul>

<h3 id="explicit-size-versus-platform-size">Explicit size versus platform size</h3>

<p>Once we introduce the above definitions, the usual question is when to use <strong>int</strong> versus <strong>int8_t</strong>/<strong>int16_t</strong>/<strong>int32_t</strong> or <strong>uint_t</strong> versus <strong>uint8_t</strong>/<strong>uint16_t</strong>/<strong>uint32_t</strong>?</p>

<p>Probably there is no single rule, but several usage cases. For applications that depend on a specific size, regardless of the platform, it is recommended to use the explicit size type definitions. Otherwise, using the platform native size may be more efficient in some cases. For example loop counts are usually better compiled when the the platform register size is used, so even if you know that the counter is small, using uint8_t instead of unsigned int may not produce a shorter/faster code (on the contrary).</p>

<p>As a general rule, when defining types that should match a memory mapped structure, or a packet header, or some other fixed size structure, you obviously need to use the explicit size definitions. For the rest, platform size definitions might be preferred.</p>

<h3 id="signed-versus-unsigned">Signed versus unsigned</h3>

<p>Another usual question is when to use int (signed) versus unsigned int. The answer is obvious, if the variable you want to represent can take negative values, then use signed variables. Otherwise, use unsigned variables.</p>

<p>One single note: sometimes, although the variable itself can take only positive values, it might be needed to also multiplex error codes on the same variable, and, in order to differentiate them, error cases are defined as impossible/illegal negative values.</p>

<p>Although an universal solution is not enforced, it is preferable NOT to return error codes multiplexed with valid content; instead, use a separate <strong>OSReturn_t</strong> for errors, and leave the value unaffected by error processing.</p>

<h2 id="user-type-definitions">User type definitions</h2>

<p>These are custom definitions, made to increase code readability and maintainability. Preferably they should rely on the previous type definitions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef uint8_t threadPriority_t;
</code></pre></div></div>

<p>If the new type can be an alias, that does not introduce a new type definition, the C++11 syntax is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using threadPriority_t = uint8_t threadPriority_t;
</code></pre></div></div>

<h2 id="enumeration-definitions">Enumeration definitions</h2>

<p>C++11 solved the old C enumeration problem and introduced strongly typed and scoped enumerations (<strong>enum class</strong>), so usually there is no need to use embedded classes with constants.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef uint32_t mode_t;

enum class Mode : mode_t
{
    Input = 0, Output = 1, Alternate = 2, Analog = 3
};

static const mode_t MODE_MASK = 0x3;
...
someFunction(Mode::Input);
</code></pre></div></div>

<h2 id="structure-definitions">Structure definitions</h2>

<p>Usually, structure definitions should be avoided, and be replaced by class definitions.</p>

<p>However, if for any reasons, struct definitions are needed, it is recommended to define both the struct name and the type, using the following syntax:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct Region_s
{
  regionAddress_t address;
  regionSize_t size;
} Region;
</code></pre></div></div>

<h2 id="aliases-to-classes">Aliases to classes</h2>

<p>For a more uniform look, type names used as aliases to class names should not end with <strong>_t</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MyClass
{
public:
  regionAddress_t address;
  regionSize_t size;
};

typedef MyClass MyClassAlias;
</code></pre></div></div>

<p>or even better, if the alias does not need to introduce a new type:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>using MyClassAlias = MyClass;
</code></pre></div></div>

<h1 id="measuring-units">Measuring units</h1>

<p>Whenever not absolutely obvious, append the measuring units to the member variable or function name.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int busFrequencyHz;
int delaySeconds;
int delayMilliseconds;
int delayMicroseconds;
int lengthMetres;
int lengthCentimetres;
int lengthMillimetres;
</code></pre></div></div>

<p>If possible, use the full unit names.</p>

<h1 id="use-of-underscore">Use of underscore</h1>

<p>Normally under camelCase rules, the underscore is no longer necessary. However, in special cases the underscore can be used as a class specifier separator.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inline static void
ledActiveOn(void);

inline static void
ISR_ledActiveOn(void);
</code></pre></div></div>

<h1 id="xcdl-configuration-definitions">XCDL configuration definitions</h1>

<p>There are several types of configuration definitions:</p>

<ul>
  <li>conditional compilation definitions</li>
  <li>value definitions</li>
</ul>

<h2 id="conditional-compilation-definitions">Conditional compilation definitions</h2>

<p>These are the definitions used to select various components to compile.</p>

<p>By convention, they all start with <strong>OS_INCLUDE_</strong> and are followed by the path of the component.</p>

<p>Examples:</p>

<ul>
  <li>OS_INCLUDE_HAL_ARCHITECTURE_SYNTHETIC_POSIX</li>
  <li>OS_INCLUDE_HAL_PLATFORM_SYNTHETIC_OSX</li>
  <li>OS_INCLUDE_PORTABLE_DIAGNOSTICS_TRACE</li>
</ul>

<h2 id="value-definitions">Value definitions</h2>

<p>These are the definitions used to configure various values at compile time.</p>

<p>By convention, they all start with the value type:</p>

<ul>
  <li><strong>OS_STRING_</strong></li>
  <li><strong>OS_INTEGER_</strong></li>
</ul>

<p>Examples:</p>

<ul>
  <li>OS_INTEGER_CORE_SCHEDULER_MAXUSERTHREADS</li>
  <li>OS_STRING_CORE_SCHEDULER_CUSTOM_HEADER</li>
</ul>

<h2 id="path-definitions">PATH definitions</h2>

<p>These special definitions are used to enter strings that contain file paths, for example for custom preprocessor includes.</p>

<p>By convention, they all start with:</p>

<ul>
  <li><strong>OS_PATH_</strong></li>
</ul>

<p>Examples:</p>

<ul>
  <li>OS_PATH_HAL_PLATFORM_PLATFORMIMPLEMENTATION</li>
</ul>

<h1 id="platform-dependencies">Platform dependencies</h1>

<p>If some parts of the code are platform dependent, test the following preprocessor definitions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if defined(__APPLE__)
#if defined(__linux__)
#if defined(__x86_64__)
</code></pre></div></div>

<p>To check the compiler:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if defined (__GNUC__)
#if __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ == 7
#if defined(__clang__)
</code></pre></div></div>

<p>To check the size of the pointer:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if __SIZEOF_POINTER__ == __SIZEOF_INT__
#elif __SIZEOF_POINTER__ == __SIZEOF_LONG__
#elif __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__
</code></pre></div></div>

<p>To check if there are no <strong>long long</strong> variables:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if !defined(__SIZEOF_LONG_LONG)
</code></pre></div></div>

<p>To check if the compiling unit is C++:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if defined (__cplusplus)
</code></pre></div></div>

<p>To check if the compiling unit is an assembly file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if defined(__ASSEMBLER__)
</code></pre></div></div>

<p>To check if optimisation is enabled (more than -O0):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if defined(__OPTIMIZE__)
</code></pre></div></div>

<p>To check if optimisation for size is enabled (-Os):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if defined(__OPTIMIZE_SIZE__)
</code></pre></div></div>

<p>To check if no inlines are enabled:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if defined(__NO_INLINE__)
</code></pre></div></div>

<p>To see the GCC defines use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ -dM -E - &lt; /dev/null
clang++ -dM -E - &lt; /dev/null
</code></pre></div></div>

<h2 id="arm-cortex-m">ARM Cortex-M</h2>

<p>When compiling Cortex-M applications, GCC 4.8 provides the following built-in definitions.</p>

<h3 id="arm-cortex-m0m0">ARM Cortex-M0/M0+</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./arm-none-eabi-gcc -mcpu=cortex-m0 -mthumb -E -dM - &lt; /dev/null | egrep -i 'thumb|arm|cortex' | sort
#define __ARMEL__ 1
#define __ARM_ARCH 6
#define __ARM_ARCH_6M__ 1
#define __ARM_ARCH_ISA_THUMB 1
#define __ARM_ARCH_PROFILE 77
#define __ARM_EABI__ 1
#define __ARM_FP 12
#define __ARM_NEON_FP 4
#define __ARM_PCS 1
#define __ARM_SIZEOF_MINIMAL_ENUM 1
#define __ARM_SIZEOF_WCHAR_T 32
#define __THUMBEL__ 1
#define __THUMB_INTERWORK__ 1
#define __VERSION__ "4.8.3 20131129 (release) [ARM/embedded-4_8-branch revision 205641]"
#define __arm__ 1
#define __thumb__ 1
</code></pre></div></div>

<h3 id="arm-cortex-m3">ARM Cortex-M3</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb -E -dM - &lt; /dev/null | egrep -i 'thumb|arm|cortex' | sort
#define __ARMEL__ 1
#define __ARM_ARCH 7
#define __ARM_ARCH_7M__ 1
#define __ARM_ARCH_EXT_IDIV__ 1
#define __ARM_ARCH_ISA_THUMB 2
#define __ARM_ARCH_PROFILE 77
#define __ARM_EABI__ 1
#define __ARM_FEATURE_CLZ 1
#define __ARM_FEATURE_LDREX 7
#define __ARM_FEATURE_QBIT 1
#define __ARM_FEATURE_SAT 1
#define __ARM_FEATURE_UNALIGNED 1
#define __ARM_FP 12
#define __ARM_NEON_FP 4
#define __ARM_PCS 1
#define __ARM_SIZEOF_MINIMAL_ENUM 1
#define __ARM_SIZEOF_WCHAR_T 32
#define __THUMBEL__ 1
#define __THUMB_INTERWORK__ 1
#define __VERSION__ "4.8.3 20131129 (release) [ARM/embedded-4_8-branch revision 205641]"
#define __arm__ 1
#define __thumb2__ 1
#define __thumb__ 1
</code></pre></div></div>

<h3 id="arm-cortex-m4">ARM Cortex-M4</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -mfloat-abi=soft -E -dM - &lt; /dev/null | egrep -i 'thumb|arm|cortex' | sort
#define __ARMEL__ 1
#define __ARM_ARCH 7
#define __ARM_ARCH_7EM__ 1
#define __ARM_ARCH_EXT_IDIV__ 1
#define __ARM_ARCH_ISA_THUMB 2
#define __ARM_ARCH_PROFILE 77
#define __ARM_EABI__ 1
#define __ARM_FEATURE_CLZ 1
#define __ARM_FEATURE_DSP 1
#define __ARM_FEATURE_LDREX 7
#define __ARM_FEATURE_QBIT 1
#define __ARM_FEATURE_SAT 1
#define __ARM_FEATURE_SIMD32 1
#define __ARM_FEATURE_UNALIGNED 1
#define __ARM_FP 12
#define __ARM_NEON_FP 4
#define __ARM_PCS 1
#define __ARM_SIZEOF_MINIMAL_ENUM 1
#define __ARM_SIZEOF_WCHAR_T 32
#define __THUMBEL__ 1
#define __THUMB_INTERWORK__ 1
#define __VERSION__ "4.8.3 20131129 (release) [ARM/embedded-4_8-branch revision 205641]"
#define __arm__ 1
#define __thumb2__ 1
#define __thumb__ 1

$ ./arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 -E -dM - &lt; /dev/null | egrep -i 'thumb|arm|cortex' | sort
#define __ARMEL__ 1
#define __ARM_ARCH 7
#define __ARM_ARCH_7EM__ 1
#define __ARM_ARCH_EXT_IDIV__ 1
#define __ARM_ARCH_ISA_THUMB 2
#define __ARM_ARCH_PROFILE 77
#define __ARM_EABI__ 1
#define __ARM_FEATURE_CLZ 1
#define __ARM_FEATURE_DSP 1
#define __ARM_FEATURE_FMA 1
#define __ARM_FEATURE_LDREX 7
#define __ARM_FEATURE_QBIT 1
#define __ARM_FEATURE_SAT 1
#define __ARM_FEATURE_SIMD32 1
#define __ARM_FEATURE_UNALIGNED 1
#define __ARM_FP 4
#define __ARM_NEON_FP 4
#define __ARM_PCS_VFP 1
#define __ARM_SIZEOF_MINIMAL_ENUM 1
#define __ARM_SIZEOF_WCHAR_T 32
#define __THUMBEL__ 1
#define __THUMB_INTERWORK__ 1
#define __VERSION__ "4.8.3 20131129 (release) [ARM/embedded-4_8-branch revision 205641]"
#define __arm__ 1
#define __thumb2__ 1
#define __thumb__ 1
</code></pre></div></div>








<ul class="share-buttons">
  <li><div class="tw-share-button"><a href="https://twitter.com/share" class="twitter-share-button" data-count="none">Tweet</a></div></li>
  <li><div class="fb-share-button" data-href="http://micro-os-plus.github.io/micro-os-plus/ii/Naming_conventions_(SE)/" data-layout="button"></div></li>
</ul>



      </div>

    </div>
  </div>

</div>

<div class="container">

  <div class="site-footer">
  <div class="site-footer-links left">
    <ul>
  <li>© 2023 Liviu Ionescu</li>
  <li>Hosted on GitHub</li>
  <li><a href="/feed.xml"><img src="/assets/images/feed-20.png" alt="RSS"></a></li>
  <li>
<a href="http://twitter.com/micro_os_plus" class="twitter-follow-button" data-show-count="false">Follow @micro_os_plus</a><script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</li>
</ul>


  </div>
  <a href="https://github.com/micro-os-plus/micro-os-plus-iii" aria-label="Homepage">
      <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
  </a>
  <div class="site-footer-links right">
    <ul>
  <li><a href="/">Home</a></li>
  <li><a href="/blog/">News</a></li>
  <li><a href="https://github.com/micro-os-plus/micro-os-plus-iii/releases">Releases</a></li>
  <li><a href="https://github.com/micro-os-plus/micro-os-plus-iii/issues">Support</a></li>
  <li><a href="/about/">About</a></li>
</ul>

  </div>
</div>


</div>

</body>
</html>
