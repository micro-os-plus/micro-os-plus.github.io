<!doctype html>
<html>

<head>

  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>C/C++ naming conventions</title>
  <meta name="description" content="CMSIS++, a proposal for the next generation CMSIS, written in C++, and the third edition of µOS++.">

  <meta property="og:title" content="C/C++ naming conventions" />
  <meta property="og:site_name" content="CMSIS++ / µOS++ IIIe" />

  <link rel="alternate" type="application/rss+xml" title="CMSIS++ / µOS++ IIIe" href="/feed.xml" />


  <meta property="article:published_time" content="2014-02-22">





  <meta name="google-site-verification" content="NT_y3tqI_8mrd8gYA_FDWHT2-tkJExOC6KBkSnyZx6c" />

  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" type="text/css" href="/stylesheets/screen.css?201603032012" media="screen">
  <link rel="stylesheet" type="text/css" href="/stylesheets/print.css?201603032012" media="print">

  <link rel="canonical" href="http://micro-os-plus.github.io/develop/naming-conventions/">



  <!--[if lt IE 9]>
  <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-16767008-14', 'auto');
  ga('send', 'pageview');

</script>



</head>


<body>

<div class="container">

  <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

  <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

  <div class="site-header">
  <table style="width:100%">
    <tr>
      <td>
        <a href="/">
          <img class="site-icon" src="/assets/icons/wall-e-icon.png" height="100" width="100">
      </a>
      </td>
      <td>
        <table class="site-title" style="width:100%">
          <tr>
            <td class="site-title">
              <a href="/">CMSIS++ / µOS++ IIIe</a>
            </td>
            <td class="site-motto" align="right">
              “Perfekt ist nicht gut genug”
            </td>
          </tr>
          <tr>
            <td class="site-description" colspan="2">
              CMSIS++, a proposal for the next generation CMSIS, written in C++, and the third edition of µOS++.
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</div>


</div>

<div class="container">

  <div class="wrapper">
    <div class="site-body">

      <div class="site-sidebar">


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      <h4 id="newsblog"><a href="/blog/">News</a></h4>

<ul>
  <li><a href="/blog/2016/03/29/license-update/">License changed from LGPL to MIT License</a></li>
  <li><a href="/blog/2016/03/10/arm-connected-community-article/">ARM Connected Community article, March 11, 2016</a></li>
  <li><a href="/blog/2016/03/03/web-new-look/">The µOS++ IIIe new web site (using GitHub Pages)</a></li>
</ul>


    </div>
  </div>


  <div class="custom-sidebar">
    <div class="boxed-group-inner">
      <h4 id="home"><a href="/">Home</a></h4>

<h4 id="cmsis">CMSIS++</h4>

<ul>
  <li><a href="/cmsis-plus/">Overview</a></li>
  <li><a href="/cmsis-plus/rtos/">RTOS API</a></li>
</ul>

<h4 id="os-iiie">µOS++ IIIe</h4>

<ul>
  <li><a href="/micro-os-plus/">Overview</a></li>
</ul>

<h4 id="xpacksxcdl">xPacks/XCDL</h4>

<ul>
  <li><a href="/xpacks/">Overview</a></li>
</ul>

<h4 id="documentation">Documentation</h4>

<ul>
  <li><a href="/user-manual/">User’s manual</a></li>
  <li><a href="/reference/cmsis-plus/">CMSIS++ reference</a></li>
</ul>

<h4 id="developer">Developer</h4>

<ul>
  <li><a href="/develop/">Overview</a></li>
  <li><a href="/develop/coding-style/">C++ coding style</a></li>
  <li><a href="/develop/references/">Links &amp; references</a></li>
</ul>

<h4 id="support">Support</h4>

<ul>
  <li><a href="/support/">Overview</a></li>
  <li><a href="/support/known-issues/">Known issues</a></li>
  <li><a href="/support/faq/">FAQ</a></li>
  <li><a href="/support/forum/">Forum</a></li>
  <li><a href="https://github.com/micro-os-plus/cmsis-plus/issues/">Report CMSIS++ issues</a></li>
  <li><a href="https://github.com/micro-os-plus/micro-os-plus-iii/issues/">Report µOS++ IIIe issues</a></li>
</ul>

<h4 id="latest-articles">Latest Articles</h4>

<ul>
  <li><a href="/articles/arm-com-2016-06-24/">CMSIS++ RTOS: fully functional reference implementation</a></li>
  <li><a href="/articles/arm-com-2016-03-11/">CMSIS++: a proposal for a future CMSIS, written in C++</a></li>
</ul>

<h4 id="license">License</h4>

<ul>
  <li><a href="https://opensource.org/licenses/MIT">MIT</a></li>
</ul>

<h4 id="aboutabout"><a href="/about/">About</a></h4>

    </div>
  </div>

  <div class="site-theme">
    This site uses the <a href="https://github.com/ilg-ul/github-jekyll-theme">GitHub Wiki-like</a> theme by <a href="https://github.com/ilg-ul">Liviu Ionescu</a>.
  </div>

</div>


      <div class="site-content">

        
<h1 class="page-title">C/C++ naming conventions</h1>
<p class="last-modified">Last modified on Tue Jun 28 15:01:13 2016 UTC.</p>


<div id="toc-container">
<table class="toc" id="toc">
<tbody>
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toc_level-1 toc_section-1">
<a href="#underscore-separated-lower-case-names"><span class="tocnumber">1</span> <span class="toctext">Underscore separated lower case names</span></a>
</li>
<li class="toc_level-1 toc_section-2">
<a href="#full-words-vs-short-words"><span class="tocnumber">2</span> <span class="toctext">Full words vs. short words</span></a>
</li>
<li class="toc_level-1 toc_section-3">
<a href="#pairs-of-opposed-actions-or-names"><span class="tocnumber">3</span> <span class="toctext">Pairs of opposed actions or names</span></a>
<ul>
<li class="toc_level-2 toc_section-4">
<a href="#antonyms"><span class="tocnumber">3.1</span> <span class="toctext">Antonyms</span></a>
</li>
<li class="toc_level-2 toc_section-5">
<a href="#technical-terms"><span class="tocnumber">3.2</span> <span class="toctext">Technical terms</span></a>
</li>
<li class="toc_level-2 toc_section-6">
<a href="#startstop-vs-beginend"><span class="tocnumber">3.3</span> <span class="toctext">start/stop vs. begin/end</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-7">
<a href="#class-names"><span class="tocnumber">4</span> <span class="toctext">Class names</span></a>
<ul>
<li class="toc_level-2 toc_section-8">
<a href="#derived-class-names"><span class="tocnumber">4.1</span> <span class="toctext">Derived class names</span></a>
</li>
<li class="toc_level-2 toc_section-9">
<a href="#abstract-base-classes"><span class="tocnumber">4.2</span> <span class="toctext">Abstract base classes</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-10">
<a href="#templates"><span class="tocnumber">5</span> <span class="toctext">Templates</span></a>
<ul>
<li class="toc_level-2 toc_section-11">
<a href="#template-class-names"><span class="tocnumber">5.1</span> <span class="toctext">Template class names</span></a>
</li>
<li class="toc_level-2 toc_section-12">
<a href="#template-parameter-types"><span class="tocnumber">5.2</span> <span class="toctext">Template parameter types</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-13">
<a href="#member-function-names"><span class="tocnumber">6</span> <span class="toctext">Member function names</span></a>
<ul>
<li class="toc_level-2 toc_section-14">
<a href="#accessorsmutators"><span class="tocnumber">6.1</span> <span class="toctext">Accessors/mutators</span></a>
</li>
<li class="toc_level-2 toc_section-15">
<a href="#getset-vs-readwrite"><span class="tocnumber">6.2</span> <span class="toctext">get/set vs. read/write</span></a>
</li>
<li class="toc_level-2 toc_section-16">
<a href="#boolean-functions"><span class="tocnumber">6.3</span> <span class="toctext">Boolean functions</span></a>
</li>
<li class="toc_level-2 toc_section-17">
<a href="#initialise-vs-configure"><span class="tocnumber">6.4</span> <span class="toctext">initialise() vs. configure()</span></a>
</li>
<li class="toc_level-2 toc_section-18">
<a href="#set-vs-configure"><span class="tocnumber">6.5</span> <span class="toctext">set() vs. configure()</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-19">
<a href="#member-variables-names"><span class="tocnumber">7</span> <span class="toctext">Member variables names</span></a>
<ul>
<li class="toc_level-2 toc_section-20">
<a href="#private-member-variables-names"><span class="tocnumber">7.1</span> <span class="toctext">Private member variables names</span></a>
</li>
<li class="toc_level-2 toc_section-21">
<a href="#static-member-variables-names"><span class="tocnumber">7.2</span> <span class="toctext">Static member variables names</span></a>
</li>
<li class="toc_level-2 toc_section-22">
<a href="#public-member-names"><span class="tocnumber">7.3</span> <span class="toctext">Public member names</span></a>
</li>
<li class="toc_level-2 toc_section-23">
<a href="#array-members"><span class="tocnumber">7.4</span> <span class="toctext">Array members</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-24">
<a href="#const--volatile"><span class="tocnumber">8</span> <span class="toctext">const &amp; volatile</span></a>
</li>
<li class="toc_level-1 toc_section-25">
<a href="#constants"><span class="tocnumber">9</span> <span class="toctext">Constants</span></a>
<ul>
<li class="toc_level-2 toc_section-26">
<a href="#static-constexpr-vs-constexpr-static"><span class="tocnumber">9.1</span> <span class="toctext">static constexpr vs. constexpr static</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-27">
<a href="#type-definitions"><span class="tocnumber">10</span> <span class="toctext">Type definitions</span></a>
<ul>
<li class="toc_level-2 toc_section-28">
<a href="#language-type-definition"><span class="tocnumber">10.1</span> <span class="toctext">Language type definition</span></a>
</li>
<li class="toc_level-2 toc_section-29">
<a href="#user-type-definitions"><span class="tocnumber">10.2</span> <span class="toctext">User type definitions</span></a>
</li>
<li class="toc_level-2 toc_section-30">
<a href="#enumeration-definitions"><span class="tocnumber">10.3</span> <span class="toctext">Enumeration definitions</span></a>
</li>
<li class="toc_level-2 toc_section-31">
<a href="#structure-definitions"><span class="tocnumber">10.4</span> <span class="toctext">Structure definitions</span></a>
</li>
<li class="toc_level-2 toc_section-32">
<a href="#aliases-to-classes"><span class="tocnumber">10.5</span> <span class="toctext">Aliases to classes</span></a>
</li>
</ul>
</li>
<li class="toc_level-1 toc_section-33">
<a href="#measuring-units"><span class="tocnumber">11</span> <span class="toctext">Measuring units</span></a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div><h2 id="underscore-separated-lower-case-names">Underscore separated lower case names</h2>

<p>In previous versions, µOS++ used the <a href="http://en.wikipedia.org/wiki/CamelCase">CamelCase</a> naming convention, but, after a long consideration, the naming was brought back to what the ISO standard libraries use, and to what existing coding styles (like MISRA, JSF) recommend, which is <strong>underscore separated lower case names</strong>.</p>

<h2 id="full-words-vs-short-words">Full words vs. short words</h2>

<p>Whenever possible, it is recommended to use the full words; shortening words in member or member function names does not make the program shorter or faster, but, when used properly, highly increases the readability of the program.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int initialise(); &lt;- instead of init();
int configure(); &lt;- instead of config();
...
int delay_seconds; &lt;- instead of delay_sec;
</code></pre>
</div>

<h2 id="pairs-of-opposed-actions-or-names">Pairs of opposed actions or names</h2>

<h3 id="antonyms">Antonyms</h3>

<p>When defining pairs of opposed actions, use the proper antonyms:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int start_acquisition();
int stop_acquisition();
...
int enable_interrupts();
int disable_interrupts();
</code></pre>
</div>

<h3 id="technical-terms">Technical terms</h3>

<p>Sometimes, even if the words are not listed in dictionaries as antonyms, the pairs of opposed names are defined by practice:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// For hardware signals, like chip select
int assert();
int deassert();
...
// For synchronisation objects, like mutex
int acquire();
int release();
</code></pre>
</div>

<h3 id="startstop-vs-beginend">start/stop vs. begin/end</h3>

<p>When defining actions, prefer <strong>start</strong>/<strong>stop</strong> to <strong>begin</strong>/<strong>end</strong>, since they have a stronger verb-like meaning (end is more an adjective than a verb).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int start_acquisition(); &lt;- instead of begin_acquisition()
int stop_acquisition(); &lt;- instead of end_acquisition()
</code></pre>
</div>

<p>However, when the meaning is adjectival, for example adding determinants to a noun, the pair begin/end is preferred.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int list_begin; &lt;- instead of list_start
int list_end; &lt;- instead of list_stop
</code></pre>
</div>

<h2 id="class-names">Class names</h2>

<p>Class names are singular names or nominative constructs; they do not need to start with upper case letters.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class logger;
class circular_buffer;
</code></pre>
</div>

<h3 id="derived-class-names">Derived class names</h3>

<p>Derived class names should extend the base class name, by adding a differentiator at the end.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class device_character_buffered : public device_character
{
 ...
};
</code></pre>
</div>

<h3 id="abstract-base-classes">Abstract base classes</h3>

<p>When an abstract class is used as a base class for concrete implementations, the suffix <code class="highlighter-rouge">_base</code> can be added to the name, and this name can be skipped in the derived class name:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class device_character_buffered_usart0 : public device_character_buffered_base
{
 ...
};
</code></pre>
</div>

<h2 id="templates">Templates</h2>

<p>Templates are a great C++ feature, that can be used for many purposes, with the common one being to implement compile time polymorphism.</p>

<h3 id="template-class-names">Template class names</h3>

<p>Template class names follow the same convention as the class names. No need to prefix them with anything.</p>

<h3 id="template-parameter-types">Template parameter types</h3>

<p>There are several template parameter types, parameters naming user-defined types (like classes), parameters naming primitive types and constant parameters (usually integer).</p>

<p>Although not required by the language, it is recommended to define parameters naming types with <code class="highlighter-rouge">typename Name_T</code>.</p>

<p>In class templates, it is recommended to alias the template parameters to new names, and use these new names in code, reserving the template parameters only to define the template syntax.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>template &lt;typename GPIO_T, typename Result_T = void, int Bit_T&gt;
class pin
{
public:
  using gpio = GPIO_T;
  using result_t = Result_T ;
  static const int bit = Bit_T;
 ...
}

// Explicit instantiation
template class pin&lt;GPIOC1&gt;;
using my_pin = class pin&lt;GPIOC1&gt; ;
</code></pre>
</div>

<h2 id="member-function-names">Member function names</h2>

<p>Function names are formed from lower case letters.</p>

<p>Since functions define actions to be performed upon the object, the function name should have the function of a predicate, and usually <strong>start with an imperative verb</strong>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int read();
</code></pre>
</div>

<p>If there are multiple functions that perform similar actions, they should differentiate by the following noun, with the function of a direct complement.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int read_byte();
long read_long();
...
void read_block();
</code></pre>
</div>

<p>The rule of starting with a verb is not absolute, when multiple functions are logically grouped by a common criteria, then predicative groups can be used as function names, and the verb is placed at the end. However, when such names occur, it might be a sign that the design can be further refined by defining additional objects, for example instead of:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void critical_enter();
void critical_exit();
</code></pre>
</div>

<p>a separate object to manage critical sections might be useful, like:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class critical
{
  void enter(void);
  void exit(void);
};
</code></pre>
</div>

<p>In this case the naming convention is again simplified, according to the initial recommendation to use a verb.</p>

<h3 id="accessorsmutators">Accessors/mutators</h3>

<p>As in most object oriented designs, member variables are usually private to the class and external direct access to them is discouraged. Instead, special accessors and mutators should be defined.</p>

<p>The name should generally contain the variable name, without parameters for the accessors and with at least one parameter for the mutators.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private:
  int prio_;

public:
  int prio(void);
  void prio(int);
</code></pre>
</div>

<h3 id="getset-vs-readwrite">get/set vs. read/write</h3>

<p>When dealing with hardware, even if the memory mapped registers are seen as class members, it is recommended to prefix member functions with read/write, not get/set, which are usually the sign of accessors/mutators in other languages.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>hal::cortexm::reg32_t
read_mode(void);

void
write_mode(const hal::cortexm::reg32_t value);
</code></pre>
</div>

<h3 id="boolean-functions">Boolean functions</h3>

<p>Functions that return boolean values should start with boolean verbs, like <strong>is</strong>, <strong>has</strong>, <strong>does</strong>. Depending on the context, past or future tense versions, like <strong>was</strong> or <strong>will</strong> may be more appropriate.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>bool is_available();
bool was_interrupted();
bool will_block();
bool has_members();
bool does_return();  &lt;-- instead of 'bool returns();'
</code></pre>
</div>

<h3 id="initialise-vs-configure">initialise() vs. configure()</h3>

<p>In classes implementing device drivers, there are member functions that can be called only before the device is enabled and functions that can be called at any moment.</p>

<p>To mark this distinction, the recommended names should start with <strong>initialise</strong> for functions that are used before the device is enabled and with <strong>configure</strong> for functions that can be used at any moment.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>bool initialise_something(void);
...
bool configure_baud_rate(baud_rate_t baud_rate);
bool configure_high_speed(void);
</code></pre>
</div>

<p>It is recommended to use the full words, shortening <code class="highlighter-rouge">initialise()</code> to <code class="highlighter-rouge">init()</code> or <code class="highlighter-rouge">configure()</code> to <code class="highlighter-rouge">config()</code> does not make the program shorter or faster.</p>

<h3 id="set-vs-configure">set() vs. configure()</h3>

<p>When dealing with device drivers, changing the state of the device is in fact a configuration change, so it is more appropriate to name functions like <code class="highlighter-rouge">configure_something()</code>.</p>

<h2 id="member-variables-names">Member variables names</h2>

<p>Similar to member functions, all member variables names start with lower case letters.</p>

<p>Since member variables define characteristics of the object, the member variables name should have the function of an attribute, and usually <strong>start with a noun</strong>. Boolean status variables naming convention should follow the boolean function naming convention, i.e. start with a verb like <strong>is</strong>, <strong>has</strong>, <strong>does</strong>, at present/past/future tense.</p>

<h3 id="private-member-variables-names">Private member variables names</h3>

<p>As the most common type of member variable names, the private member variables should be suffixed with <code class="highlighter-rouge">_</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private:
  int count_;
  char* buffer_address_;
  int buffer_size_;

  bool is_running_;
  bool was_cancelled_;
</code></pre>
</div>

<h3 id="static-member-variables-names">Static member variables names</h3>

<p>Static member variables need not be prefixed or suffixed.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static constexpr uint32_t frequency_hz = 1;
</code></pre>
</div>

<h3 id="public-member-names">Public member names</h3>

<p>As an exception to the above rules, some globally available member variables, can be named without the <code class="highlighter-rouge">_</code> suffix.</p>

<h3 id="array-members">Array members</h3>

<p>For a better code readability, it is recommended to name array members or pointers to arrays explicitly, like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>thread** waiting_array;
unsigned short waiting_array_size;
</code></pre>
</div>

<h2 id="const--volatile">const &amp; volatile</h2>

<p>The rules for using these keywords are sometimes tricky, and the easiest to remember is <strong><em>const makes a constant whatever is on its left</em></strong>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code> int* const p1; // constant pointer to int
 const int* p2; // pointer to an int constant
 const int* const p3; // constant pointer to an int constant
</code></pre>
</div>

<p>Systematic use of the above rule would put the type of scalars at the left of const, which is not that usual:</p>

<div class="highlighter-rouge"><pre class="highlight"><code> int const n; // constant integer
</code></pre>
</div>

<p>So, for scalars and for constants, it is also acceptable to use the more common order:</p>

<div class="highlighter-rouge"><pre class="highlight"><code> const int n;
 static const int my_const = 7;
</code></pre>
</div>

<h2 id="constants">Constants</h2>

<p>Constant names are regular names, all lower case.</p>

<p>Although in C/C++ it is possible to define constants using the preprocessor, it is recommended to use them only for project configuration variables, otherwise use only typed definitions, and the compiler might catch some errors.</p>

<p>For individual definitions, the recommended way is to use <code class="highlighter-rouge">constexpr</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>constexpr thread_id_t no_id = 0xFF;
</code></pre>
</div>

<p>For definitions inside a class, use <code class="highlighter-rouge">static constexpr</code> members.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static constexpr return_t os_ok = 0;
</code></pre>
</div>

<p>Depending on the specific scope, if the constants are to be used only inside the given class, they can be made private.</p>

<p>Constants can be grouped in separated classes, that groups together various return values, although enums would be probably more appropriate.</p>

<p>For group of constants, the recommended method is to use enumerations.</p>

<h3 id="static-constexpr-vs-constexpr-static">static constexpr vs. constexpr static</h3>

<p>The recommended order is <code class="highlighter-rouge">static constexpr</code>.</p>

<h2 id="type-definitions">Type definitions</h2>

<p>For a better code maintainability, where needed, it is recommended to use type definitions instead of direct C/C++ scalar types.</p>

<p>Scalar type definitions should start with lower case letters and end with <code class="highlighter-rouge">_t</code>; class aliases should follow the usual naming convention of class names.</p>

<h3 id="language-type-definition">Language type definition</h3>

<h4 id="explicit-size-definitions">Explicit size definitions</h4>

<p>These are mainly the definitions from <code class="highlighter-rouge">&lt;stdint.h&gt;</code></p>

<ul>
  <li><code class="highlighter-rouge">uint8_t</code>, <code class="highlighter-rouge">int8_t</code></li>
  <li><code class="highlighter-rouge">uint16_t</code>, <code class="highlighter-rouge">int16_t</code></li>
  <li><code class="highlighter-rouge">uint32_t</code>, <code class="highlighter-rouge">int32_t</code></li>
</ul>

<h4 id="explicit-size-versus-platform-size">Explicit size versus platform size</h4>

<p>Once we introduce the above definitions, the usual question is when to use <code class="highlighter-rouge">int</code> versus <code class="highlighter-rouge">int8_t</code>/<code class="highlighter-rouge">int16_t</code>/<code class="highlighter-rouge">int32_t</code> or <code class="highlighter-rouge">unsigned int</code> versus <code class="highlighter-rouge">uint8_t</code>/<code class="highlighter-rouge">uint16_t</code>/<code class="highlighter-rouge">uint32_t</code>?</p>

<p>Probably there is no single rule, but several usage cases. For applications that depend on a specific size, regardless of the platform, it is recommended to use the explicit size type definitions. Otherwise, using the platform native size may be more efficient in some cases. For example loop counts are usually better compiled when the the platform register size is used, so even if you know that the counter is small, using <code class="highlighter-rouge">uint8_t</code> instead of unsigned int may not produce a shorter/faster code (on the contrary).</p>

<p>As a general rule, when defining types that should match a memory mapped structure, or a packet header, or some other fixed size structure, you obviously need to use the explicit size definitions. For the rest, platform size definitions might be preferred.</p>

<h4 id="signed-versus-unsigned">Signed versus unsigned</h4>

<p>Another usual question is when to use <code class="highlighter-rouge">int</code> (signed) versus <code class="highlighter-rouge">unsigned int</code>. The answer is obvious, if the variable you want to represent can take negative values, then use signed variables. Otherwise, use unsigned variables.</p>

<p>One single note: sometimes, although the variable itself can take only positive values, it might be needed to also multiplex error codes on the same variable, and, in order to differentiate them, error cases are defined as impossible/illegal negative values.</p>

<p>Although an universal solution is not enforced, it is preferable NOT to return error codes multiplexed with valid content; instead, return the error code and use a separate pointer parameter to return values, and leave the value unaffected by error processing.</p>

<h3 id="user-type-definitions">User type definitions</h3>

<p>These are custom definitions, made to increase code readability and maintainability. Preferably they should rely on the previous type definitions.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef uint8_t thread_priority_t;
</code></pre>
</div>

<p>If the new type can be an alias, that does not introduce a new type definition, the C++11 syntax is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>using thread_priority_t = uint8_t;
</code></pre>
</div>

<h3 id="enumeration-definitions">Enumeration definitions</h3>

<p>C++11 solved the old C enumeration problem and introduced strongly typed and scoped enumerations (<code class="highlighter-rouge">enum class</code>), so usually there is no need to use embedded classes with constants.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef uint32_t mode_t;

enum class mode : mode_t
{
    input = 0, output = 1, alternate = 2, analog = 3
};

static const mode_t mode_mask = 0x3;
...
some_function(mode::input);
</code></pre>
</div>

<h3 id="structure-definitions">Structure definitions</h3>

<p>Usually, structure definitions should be avoided, and be replaced by class definitions.</p>

<p>However, if for any reasons, struct definitions are needed, it is recommended to define both the struct name and the type, using the following syntax:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef struct region_s
{
  region_address_t address;
  region_size_t size;
} region_t;
</code></pre>
</div>

<h3 id="aliases-to-classes">Aliases to classes</h3>

<p>For a more uniform look, type names used as aliases to class names need not end with <code class="highlighter-rouge">_t</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class my_class
{
public:
  region_address_t address;
  region_size_t size;
};

using my_class_alias = my_class;
</code></pre>
</div>

<h2 id="measuring-units">Measuring units</h2>

<p>Whenever not absolutely obvious, append the measuring units to the member variable or function name.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int bus_frequency_hz;
int delay_seconds;
int delay_milliseconds;
int delay_microseconds;
int length_metres;
int length_centimetres;
int length_millimetres;
</code></pre>
</div>

<p>If possible, use the full unit names.</p>








<ul class="share-buttons">
  <li><div class="fb-share-button" data-href="http://micro-os-plus.github.io/develop/naming-conventions/" data-layout="button"></div></li>
  <li><div class="tw-share-button"><a href="https://twitter.com/share" class="twitter-share-button" data-count="none">Tweet</a></div></li>
</ul>



      </div>

    </div>
  </div>

</div>

<div class="container">

  <div class="site-footer">
  <div class="site-footer-links left">
    <ul>
  <li>© 2016 Liviu Ionescu</li>
  <li>Hosted on GitHub</li>
  <li><a href="/feed.xml"><img src="/assets/images/feed-20.png" alt="RSS" /></a></li>
</ul>


  </div>
  <a href="https://github.com/micro-os-plus/cmsis-plus" aria-label="Homepage">
      <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
  </a>
  <div class="site-footer-links right">
    <ul>
  <li><a href="/">Home</a></li>
  <li><a href="/blog/">News</a></li>
  <li><a href="https://github.com/micro-os-plus/cmsis-plus/releases">Releases</a></li>
  <li><a href="https://github.com/micro-os-plus/cmsis-plus/issues">Support</a></li>
  <li><a href="/about/">About</a></li>
</ul>

  </div>
</div>


</div>

</body>
</html>
